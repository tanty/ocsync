commit 8a3e6176308da97a540423abd4c670defb4cac18
Author: Olivier Goffart <ogoffart@woboq.com>
Date:   Thu Nov 14 18:55:39 2013 +0100

    Don't put csync_owncloud in a plugin.
    
    It is now statically linked

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 5904a8f..ebb5bfd 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -58,7 +58,6 @@ if (MEM_NULL_TESTS)
 endif (MEM_NULL_TESTS)
 
 add_subdirectory(src)
-add_subdirectory(modules)
 add_subdirectory(config)
 add_subdirectory(doc)
 
diff --git a/modules/CMakeLists.txt b/modules/CMakeLists.txt
deleted file mode 100644
index 27ac8fb..0000000
--- a/modules/CMakeLists.txt
+++ /dev/null
@@ -1,49 +0,0 @@
-project(modules C)
-
-find_package(LibSSH 0.4.0)
-find_package(Neon 0.29.0)
-
-set(PLUGIN_VERSION_INSTALL_DIR "${PLUGIN_INSTALL_DIR}-${LIBRARY_SOVERSION}")
-
-set(MODULES_PUBLIC_INCLUDE_DIRS
-  ${CMAKE_CURRENT_SOURCE_DIR}
-  CACHE INTERNAL "modules include directories"
-)
-
-set(MODULES_PRIVATE_INCLUDE_DIRS
-  ${CSTDLIB_PUBLIC_INCLUDE_DIRS}
-  ${CSYNC_PUBLIC_INCLUDE_DIRS}
-  ${HTTPBF_PUBLIC_INCLUDE_DIRS}
-)
-
-set(OWNCLOUD_PLUGIN
-  ocsync_owncloud
-)
-
-include_directories(
-  ${MODULES_PUBLIC_INCLUDE_DIRS}
-  ${MODULES_PRIVATE_INCLUDE_DIRS}
-)
-
-if (NEON_FOUND)
-    include_directories( ${NEON_INCLUDE_DIRS} )
-    macro_add_plugin(${OWNCLOUD_PLUGIN} csync_owncloud.c csync_owncloud_recursive_propfind.c csync_owncloud_util.c)
-    target_link_libraries(${OWNCLOUD_PLUGIN} ${CSYNC_LIBRARY} ${NEON_LIBRARIES} ${HTTPBF_LIBRARY})
-
-    install(
-        TARGETS
-	${OWNCLOUD_PLUGIN}
-        DESTINATION
-        ${PLUGIN_VERSION_INSTALL_DIR}
-        )
-endif (NEON_FOUND)
-
-macro_add_plugin(ocsync_dummy csync_dummy.c)
-target_link_libraries(ocsync_dummy ${CSYNC_LIBRARY})
-
-# create test file as bad plugin for the vio testcase
-file(WRITE
-  ${CMAKE_CURRENT_BINARY_DIR}/ocsync_bad.so
-  "bad plugin"
-)
-
diff --git a/modules/csync_dummy.c b/modules/csync_dummy.c
deleted file mode 100644
index 8f82c67..0000000
--- a/modules/csync_dummy.c
+++ /dev/null
@@ -1,215 +0,0 @@
-/*
- * libcsync -- a library to sync a directory with another
- *
- * Copyright (c) 2008      by Andreas Schneider <mail@cynapses.org>
- *
- * This program is free software = NULL, you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation = NULL, either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY = NULL, without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program = NULL, if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#include <errno.h>
-#include <stdio.h>
-#include <time.h>
-
-#include "c_lib.h"
-#include "vio/csync_vio_module.h"
-#include "vio/csync_vio_file_stat.h"
-
-#ifdef NDEBUG
-#define DEBUG_DUMMY(x)
-#else
-#define DEBUG_DUMMY(x) printf x
-#endif
-
-csync_vio_method_handle_t *mh = NULL;
-csync_vio_file_stat_t fs;
-
-/*
- * file functions
- */
-
-static csync_vio_method_handle_t *dummy_open(const char *durl, int flags, mode_t mode) {
-  (void) durl;
-  (void) flags;
-  (void) mode;
-
-  return &mh;
-}
-
-static csync_vio_method_handle_t *dummy_creat(const char *durl, mode_t mode) {
-  (void) durl;
-  (void) mode;
-
-  return &mh;
-}
-
-static int dummy_close(csync_vio_method_handle_t *fhandle) {
-  (void) fhandle;
-
-  return 0;
-}
-
-static ssize_t dummy_read(csync_vio_method_handle_t *fhandle, void *buf, size_t count) {
-  (void) fhandle;
-  (void) buf;
-  (void) count;
-
-  return 0;
-}
-
-static ssize_t dummy_write(csync_vio_method_handle_t *fhandle, const void *buf, size_t count) {
-  (void) fhandle;
-  (void) buf;
-  (void) count;
-
-  return 0;
-}
-
-static int64_t dummy_lseek(csync_vio_method_handle_t *fhandle, int64_t offset, int whence) {
-  (void) fhandle;
-  (void) offset;
-  (void) whence;
-
-  return 0;
-}
-
-/*
- * directory functions
- */
-
-static csync_vio_method_handle_t *dummy_opendir(const char *name) {
-  (void) name;
-
-  return &mh;
-}
-
-static int dummy_closedir(csync_vio_method_handle_t *dhandle) {
-  (void) dhandle;
-
-  return 0;
-}
-
-static csync_vio_file_stat_t *dummy_readdir(csync_vio_method_handle_t *dhandle) {
-  (void) dhandle;
-
-  return &fs;
-}
-
-static int dummy_mkdir(const char *uri, mode_t mode) {
-  (void) uri;
-  (void) mode;
-
-  return 0;
-}
-
-static int dummy_rmdir(const char *uri) {
-  (void) uri;
-
-  return 0;
-}
-
-static int dummy_stat(const char *uri, csync_vio_file_stat_t *buf) {
-  time_t now;
-
-  buf->name = c_basename(uri);
-  if (buf->name == NULL) {
-    csync_vio_file_stat_destroy(buf);
-    return -1;
-  }
-  buf->fields = CSYNC_VIO_FILE_STAT_FIELDS_NONE;
-
-  time(&now);
-  buf->mtime = now;
-  buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_MTIME;
-
-  return 0;
-}
-
-static int dummy_rename(const char *olduri, const char *newuri) {
-  (void) olduri;
-  (void) newuri;
-
-  return 0;
-}
-
-static int dummy_unlink(const char *uri) {
-  (void) uri;
-
-  return 0;
-}
-
-static int dummy_chmod(const char *uri, mode_t mode) {
-  (void) uri;
-  (void) mode;
-
-  return 0;
-}
-
-static int dummy_chown(const char *uri, uid_t owner, gid_t group) {
-  (void) uri;
-  (void) owner;
-  (void) group;
-
-  return 0;
-}
-
-static int dummy_utimes(const char *uri, const struct timeval *times) {
-  (void) uri;
-  (void) times;
-
-  return 0;
-}
-
-csync_vio_method_t dummy_method = {
-  .method_table_size = sizeof(csync_vio_method_t),
-  .open = dummy_open,
-  .creat = dummy_creat,
-  .close = dummy_close,
-  .read = dummy_read,
-  .write = dummy_write,
-  .lseek = dummy_lseek,
-  .opendir = dummy_opendir,
-  .closedir = dummy_closedir,
-  .readdir = dummy_readdir,
-  .mkdir = dummy_mkdir,
-  .rmdir = dummy_rmdir,
-  .stat = dummy_stat,
-  .rename = dummy_rename,
-  .unlink = dummy_unlink,
-  .chmod = dummy_chmod,
-  .chown = dummy_chown,
-  .utimes = dummy_utimes
-};
-
-csync_vio_method_t *vio_module_init(const char *method_name, const char *args,
-    csync_auth_callback cb, void *userdata) {
-  DEBUG_DUMMY(("csync_dummy - method_name: %s\n", method_name));
-  DEBUG_DUMMY(("csync_dummy - args: %s\n", args));
-
-  (void) method_name;
-  (void) args;
-  (void) cb;
-  (void) userdata;
-
-  mh = (void *) method_name;
-  fs.mtime = 42;
-
-  return &dummy_method;
-}
-
-void vio_module_shutdown(csync_vio_method_t *method) {
-  (void) method;
-}
-
-/* vim: set ts=8 sw=2 et cindent: */
diff --git a/modules/csync_owncloud.c b/modules/csync_owncloud.c
deleted file mode 100644
index 1caf1fa..0000000
--- a/modules/csync_owncloud.c
+++ /dev/null
@@ -1,1224 +0,0 @@
-/*
- * libcsync -- a library to sync a directory with another
- *
- * Copyright (c) 2011      by Andreas Schneider <asn@cryptomilk.org>
- * Copyright (c) 2012      by Klaas Freitag <freitag@owncloud.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "csync_owncloud.h"
-
-#include <inttypes.h>
-
-/*
- * free the fetchCtx
- */
-static void free_fetchCtx( struct listdir_context *ctx )
-{
-    struct resource *newres, *res;
-    if( ! ctx ) return;
-    newres = ctx->list;
-    res = newres;
-
-    ctx->ref--;
-    if (ctx->ref > 0) return;
-
-    SAFE_FREE(ctx->target);
-
-    while( res ) {
-        SAFE_FREE(res->uri);
-        SAFE_FREE(res->name);
-        SAFE_FREE(res->md5);
-        memset( res->file_id, 0, FILE_ID_BUF_SIZE+1 );
-
-        newres = res->next;
-        SAFE_FREE(res);
-        res = newres;
-    }
-    SAFE_FREE(ctx);
-}
-
-
-/*
- * local variables.
- */
-
-struct dav_session_s dav_session; /* The DAV Session, initialised in dav_connect */
-int _connected = 0;                   /* flag to indicate if a connection exists, ie.
-                                     the dav_session is valid */
-
-csync_auth_callback _authcb;
-long long chunked_total_size = 0;
-long long chunked_done = 0;
-
-struct listdir_context *propfind_cache = 0;
-
-bool is_first_propfind = true;
-
-
-csync_vio_file_stat_t _stat_cache;
-/* id cache, cache the ETag: header of a GET request */
-struct { char *uri; char *id;  } _id_cache = { NULL, NULL };
-
-static void clean_caches() {
-    clear_propfind_recursive_cache();
-
-    free_fetchCtx(propfind_cache);
-    propfind_cache = NULL;
-
-    SAFE_FREE(_stat_cache.name);
-    SAFE_FREE(_stat_cache.etag );
-    memset( _stat_cache.file_id, 0, FILE_ID_BUF_SIZE+1 );
-
-    SAFE_FREE(_id_cache.uri);
-    SAFE_FREE(_id_cache.id);
-}
-
-
-
-#define PUT_BUFFER_SIZE 1024*5
-
-char _buffer[PUT_BUFFER_SIZE];
-
-/*
- * helper method to build up a user text for SSL problems, called from the
- * verify_sslcert callback.
- */
-static void addSSLWarning( char *ptr, const char *warn, int len )
-{
-    char *concatHere = ptr;
-    int remainingLen = 0;
-
-    if( ! (warn && ptr )) return;
-    remainingLen = len - strlen(ptr);
-    if( remainingLen <= 0 ) return;
-    concatHere = ptr + strlen(ptr);  /* put the write pointer to the end. */
-    strncpy( concatHere, warn, remainingLen );
-}
-
-/*
- * Callback to verify the SSL certificate, called from libneon.
- * It analyzes the SSL problem, creates a user information text and passes
- * it to the csync callback to ask the user.
- */
-#define LEN 4096
-static int verify_sslcert(void *userdata, int failures,
-                          const ne_ssl_certificate *certificate)
-{
-    char problem[LEN];
-    char buf[MAX(NE_SSL_DIGESTLEN, NE_ABUFSIZ)];
-    int ret = -1;
-    const ne_ssl_certificate *cert = certificate;
-
-    (void) userdata;
-    memset( problem, 0, LEN );
-
-    while( cert ) {
-
-      addSSLWarning( problem, "There are problems with the SSL certificate:\n", LEN );
-      if( failures & NE_SSL_NOTYETVALID ) {
-        addSSLWarning( problem, " * The certificate is not yet valid.\n", LEN );
-      }
-      if( failures & NE_SSL_EXPIRED ) {
-        addSSLWarning( problem, " * The certificate has expired.\n", LEN );
-      }
-
-      if( failures & NE_SSL_UNTRUSTED ) {
-        addSSLWarning( problem, " * The certificate is not trusted!\n", LEN );
-      }
-      if( failures & NE_SSL_IDMISMATCH ) {
-        addSSLWarning( problem, " * The hostname for which the certificate was "
-                       "issued does not match the hostname of the server\n", LEN );
-      }
-      if( failures & NE_SSL_BADCHAIN ) {
-        addSSLWarning( problem, " * The certificate chain contained a certificate other than the server cert\n", LEN );
-      }
-      if( failures & NE_SSL_REVOKED ) {
-        addSSLWarning( problem, " * The server certificate has been revoked by the issuing authority.\n", LEN );
-      }
-
-      if (ne_ssl_cert_digest(cert, buf) == 0) {
-        addSSLWarning( problem, "Certificate fingerprint: ", LEN );
-        addSSLWarning( problem, buf, LEN );
-        addSSLWarning( problem, "\n", LEN );
-      }
-      cert = ne_ssl_cert_signedby( cert );
-    }
-    addSSLWarning( problem, "Do you want to accept the certificate chain anyway?\nAnswer yes to do so and take the risk: ", LEN );
-
-    if( _authcb ){
-        /* call the csync callback */
-        DEBUG_WEBDAV("Call the csync callback for SSL problems");
-        memset( buf, 0, NE_ABUFSIZ );
-        (*_authcb) ( problem, buf, NE_ABUFSIZ-1, 1, 0, NULL );
-        if( buf[0] == 'y' || buf[0] == 'Y') {
-            ret = 0;
-        } else {
-            DEBUG_WEBDAV("Authentication callback replied %s", buf );
-
-        }
-    }
-    DEBUG_WEBDAV("## VERIFY_SSL CERT: %d", ret  );
-      return ret;
-}
-
-/*
- * Authentication callback. Is set by ne_set_server_auth to be called
- * from the neon lib to authenticate a request.
- */
-static int ne_auth( void *userdata, const char *realm, int attempt,
-                    char *username, char *password)
-{
-    char buf[NE_ABUFSIZ];
-
-    (void) userdata;
-    (void) realm;
-
-    /* DEBUG_WEBDAV( "Authentication required %s", realm ); */
-    if( username && password ) {
-        DEBUG_WEBDAV( "Authentication required %s", username );
-        if( dav_session.user ) {
-            /* allow user without password */
-            if( strlen( dav_session.user ) < NE_ABUFSIZ ) {
-                strcpy( username, dav_session.user );
-            }
-            if( dav_session.pwd && strlen( dav_session.pwd ) < NE_ABUFSIZ ) {
-                strcpy( password, dav_session.pwd );
-            }
-        } else if( _authcb != NULL ){
-            /* call the csync callback */
-            DEBUG_WEBDAV("Call the csync callback for %s", realm );
-            memset( buf, 0, NE_ABUFSIZ );
-            (*_authcb) ("Enter your username: ", buf, NE_ABUFSIZ-1, 1, 0, NULL );
-            if( strlen(buf) < NE_ABUFSIZ ) {
-                strcpy( username, buf );
-            }
-            memset( buf, 0, NE_ABUFSIZ );
-            (*_authcb) ("Enter your password: ", buf, NE_ABUFSIZ-1, 0, 0, NULL );
-            if( strlen(buf) < NE_ABUFSIZ) {
-                strcpy( password, buf );
-            }
-        } else {
-            DEBUG_WEBDAV("I can not authenticate!");
-        }
-    }
-    return attempt;
-}
-
-/*
- * Authentication callback. Is set by ne_set_proxy_auth to be called
- * from the neon lib to authenticate against a proxy. The data to authenticate
- * against comes from mirall throught vio_module_init function.
- */
-static int ne_proxy_auth( void *userdata, const char *realm, int attempt,
-                          char *username, char *password)
-{
-    (void) userdata;
-    (void) realm;
-    if( dav_session.proxy_user && strlen( dav_session.proxy_user ) < NE_ABUFSIZ) {
-        strcpy( username, dav_session.proxy_user );
-        if( dav_session.proxy_pwd && strlen( dav_session.proxy_pwd ) < NE_ABUFSIZ) {
-            strcpy( password, dav_session.proxy_pwd );
-        }
-    }
-    /* NTLM needs several attempts */
-    return (attempt < 3) ? 0 : -1;
-}
-
-/* Configure the proxy depending on the variables */
-static int configureProxy( ne_session *session )
-{
-    int port = 8080;
-    int re = -1;
-
-    if( ! session ) return -1;
-    if( ! dav_session.proxy_type ) return 0; /* Go by NoProxy per default */
-
-    if( dav_session.proxy_port > 0 ) {
-        port = dav_session.proxy_port;
-    }
-
-    if( c_streq(dav_session.proxy_type, "NoProxy" )) {
-        DEBUG_WEBDAV("No proxy configured.");
-        re = 0;
-    } else if( c_streq(dav_session.proxy_type, "DefaultProxy") ||
-               c_streq(dav_session.proxy_type, "HttpProxy")    ||
-               c_streq(dav_session.proxy_type, "HttpCachingProxy") ||
-               c_streq(dav_session.proxy_type, "Socks5Proxy")) {
-
-        if( dav_session.proxy_host ) {
-            DEBUG_WEBDAV("%s at %s:%d", dav_session.proxy_type, dav_session.proxy_host, port );
-            if (c_streq(dav_session.proxy_type, "Socks5Proxy")) {
-                ne_session_socks_proxy(session, NE_SOCK_SOCKSV5, dav_session.proxy_host, port,
-                                       dav_session.proxy_user, dav_session.proxy_pwd);
-            } else {
-                ne_session_proxy(session, dav_session.proxy_host, port );
-            }
-            re = 2;
-        } else {
-            DEBUG_WEBDAV("%s requested but no proxy host defined.", dav_session.proxy_type );
-	    /* we used to try ne_system_session_proxy here, but we should rather err out
-	       to behave exactly like the caller. */
-        }
-    } else {
-        DEBUG_WEBDAV( "Unsupported Proxy: %s", dav_session.proxy_type );
-    }
-
-    return re;
-}
-
-/*
- * This hook is called for with the response of a request. Here its checked
- * if a Set-Cookie header is there for the PHPSESSID. The key is stored into
- * the webdav session to be added to subsequent requests.
- */
-static void post_request_hook(ne_request *req, void *userdata, const ne_status *status)
-{
-    const char *set_cookie_header = NULL;
-    const char *sc  = NULL;
-    char *key = NULL;
-
-    (void) userdata;
-
-    if (dav_session.session_key)
-        return; /* We already have a session cookie, and we should ignore other ones */
-
-    if(!(status && req)) return;
-    if( status->klass == 2 || status->code == 401 ) {
-        /* successful request */
-        set_cookie_header =  ne_get_response_header( req, "Set-Cookie" );
-        if( set_cookie_header ) {
-            DEBUG_WEBDAV(" Set-Cookie found: %s", set_cookie_header);
-            /* try to find a ', ' sequence which is the separator of neon if multiple Set-Cookie
-             * headers are there.
-             * The following code parses a string like this:
-             * Set-Cookie: 50ace6bd8a669=p537brtt048jh8srlp2tuep7em95nh9u98mj992fbqc47d1aecp1;
-             */
-            sc = set_cookie_header;
-            while(sc) {
-                const char *sc_val = sc;
-                const char *sc_end = sc_val;
-                int cnt = 0;
-                int len = strlen(sc_val); /* The length of the rest of the header string. */
-
-                while( cnt < len && *sc_end != ';' && *sc_end != ',') {
-                    cnt++;
-                    sc_end++;
-                }
-                if( cnt == len ) {
-                    /* exit: We are at the end. */
-                    sc = NULL;
-                } else if( *sc_end == ';' ) {
-                    /* We are at the end of the session key. */
-                    int keylen = sc_end-sc_val;
-                    if( key ) {
-                        int oldlen = strlen(key);
-                        key = c_realloc(key, oldlen + 2 + keylen+1);
-                        strcpy(key + oldlen, "; ");
-                        strncpy(key + oldlen + 2, sc_val, keylen);
-                        key[oldlen + 2 + keylen] = '\0';
-                    } else {
-                        key = c_malloc(keylen+1);
-                        strncpy( key, sc_val, keylen );
-                        key[keylen] = '\0';
-                    }
-
-                    /* now search for a ',' to find a potential other header entry */
-                    while(cnt < len && *sc_end != ',') {
-                        cnt++;
-                        sc_end++;
-                    }
-                    if( cnt < len )
-                        sc = sc_end+2; /* mind the space after the comma */
-                    else
-                        sc = NULL;
-                } else if( *sc_end == ',' ) {
-                    /* A new entry is to check. */
-                    if( *(sc_end + 1) == ' ') {
-                        sc = sc_end+2;
-                    } else {
-                        /* error condition */
-                        sc = NULL;
-                    }
-                }
-            }
-        }
-    } else {
-        DEBUG_WEBDAV("Request failed, don't take session header.");
-    }
-    if( key ) {
-        DEBUG_WEBDAV("----> Session-key: %s", key);
-        SAFE_FREE(dav_session.session_key);
-        dav_session.session_key = key;
-    }
-}
-
-/*
- * this hook is called just after a request has been created, before its sent.
- * Here it is used to set the proxy connection header if available.
- */
-static void request_created_hook(ne_request *req, void *userdata,
-                                 const char *method, const char *requri)
-{
-    (void) userdata;
-    (void) method;
-    (void) requri;
-
-    if( !req ) return;
-
-    if(dav_session.proxy_type) {
-        /* required for NTLM */
-        ne_add_request_header(req, "Proxy-Connection", "Keep-Alive");
-    }
-}
-
-/*
- * this hook is called just before a request has been sent.
- * Here it is used to set the session cookie if available.
- */
-static void pre_send_hook(ne_request *req, void *userdata,
-                          ne_buffer *header)
-{
-    (void) userdata;
-
-    if( !req ) return;
-
-    if(dav_session.session_key) {
-        ne_buffer_concat(header, "Cookie: ", dav_session.session_key, "\r\n", NULL);
-    }
-}
-
-static int post_send_hook(ne_request *req, void *userdata,
-                          const ne_status *status)
-{
-    const char *location;
-
-    (void) userdata;
-    (void) status;
-
-    location = ne_get_response_header(req, "Location");
-
-    if( !location ) return NE_OK;
-
-    if( dav_session.redir_callback ) {
-        if( dav_session.redir_callback( dav_session.csync_ctx, location ) ) {
-            return NE_REDIRECT;
-        } else {
-            return NE_RETRY;
-        }
-    }
-
-    return NE_REDIRECT;
-}
-
-// as per http://sourceforge.net/p/predef/wiki/OperatingSystems/
-// extend as required
-static const char* get_platform() {
-#if defined (_WIN32)
-    return "Windows";
-#elif defined(__APPLE__)
-    return "Macintosh";
-#elif defined(__gnu_linux__)
-    return "Linux";
-#elif defined(__DragonFly__)
-    /* might also define __FreeBSD__ */
-    return "DragonFlyBSD";
-#elif defined(__FreeBSD__)
-    return "FreeBSD";
-#elif defined(__NetBSD__)
-    return "NetBSD";
-#elif defined(__OpenBSD__)
-    return "OpenBSD";
-#elif defined(sun) || defined(__sun)
-    return "Solaris";
-#else
-    return "Unknown OS";
-#endif
-}
-
-/*
- * Connect to a DAV server
- * This function sets the flag _connected if the connection is established
- * and returns if the flag is set, so calling it frequently is save.
- */
-static int dav_connect(const char *base_url) {
-    int useSSL = 0;
-    int rc;
-    char protocol[6] = {'\0'};
-    char uaBuf[256];
-    char *path = NULL;
-    char *scheme = NULL;
-    char *host = NULL;
-    unsigned int port = 0;
-    int proxystate = -1;
-
-    if (_connected) {
-        return 0;
-    }
-
-    rc = c_parse_uri( base_url, &scheme, &dav_session.user, &dav_session.pwd, &host, &port, &path );
-    if( rc < 0 ) {
-        DEBUG_WEBDAV("Failed to parse uri %s", base_url );
-        goto out;
-    }
-
-    DEBUG_WEBDAV("* scheme %s", scheme );
-    DEBUG_WEBDAV("* host %s", host );
-    DEBUG_WEBDAV("* port %u", port );
-    DEBUG_WEBDAV("* path %s", path );
-
-    if( strcmp( scheme, "owncloud" ) == 0 ) {
-        strcpy( protocol, "http");
-    } else if( strcmp( scheme, "ownclouds" ) == 0 ) {
-        strcpy( protocol, "https");
-        useSSL = 1;
-    } else {
-        DEBUG_WEBDAV("Invalid scheme %s, go outa here!", scheme );
-        rc = -1;
-        goto out;
-    }
-
-    DEBUG_WEBDAV("* user %s", dav_session.user ? dav_session.user : "");
-
-    if (port == 0) {
-        port = ne_uri_defaultport(protocol);
-    }
-
-#if 0
-    rc = ne_sock_init();
-    DEBUG_WEBDAV("ne_sock_init: %d", rc );
-    if (rc < 0) {
-        rc = -1;
-        goto out;
-    }
-#endif
-
-    dav_session.ctx = ne_session_create( protocol, host, port);
-
-    if (dav_session.ctx == NULL) {
-        DEBUG_WEBDAV("Session create with protocol %s failed", protocol );
-        rc = -1;
-        goto out;
-    }
-
-    if (dav_session.read_timeout == 0)
-        dav_session.read_timeout = 300;  // set 300 seconds as default.
-
-    ne_set_read_timeout(dav_session.ctx, dav_session.read_timeout);
-
-    snprintf( uaBuf, sizeof(uaBuf), "Mozilla/5.0 (%s) csyncoC/%s",
-              get_platform(), CSYNC_STRINGIFY( LIBCSYNC_VERSION ));
-    ne_set_useragent( dav_session.ctx, uaBuf);
-    ne_set_server_auth(dav_session.ctx, ne_auth, 0 );
-
-    if( useSSL ) {
-        if (!ne_has_support(NE_FEATURE_SSL)) {
-            DEBUG_WEBDAV("Error: SSL is not enabled.");
-            rc = -1;
-            goto out;
-        }
-
-        ne_ssl_trust_default_ca( dav_session.ctx );
-        ne_ssl_set_verify( dav_session.ctx, verify_sslcert, 0 );
-    }
-
-    /* Hook called when a request is created. It sets the proxy connection header. */
-    ne_hook_create_request( dav_session.ctx, request_created_hook, NULL );
-    /* Hook called after response headers are read. It gets the Session ID. */
-    ne_hook_post_headers( dav_session.ctx, post_request_hook, NULL );
-    /* Hook called before a request is sent. It sets the cookies. */
-    ne_hook_pre_send( dav_session.ctx, pre_send_hook, NULL );
-    /* Hook called after request is dispatched. Used for handling possible redirections. */
-    ne_hook_post_send( dav_session.ctx, post_send_hook, NULL );
-
-    /* Proxy support */
-    proxystate = configureProxy( dav_session.ctx );
-    if( proxystate < 0 ) {
-        DEBUG_WEBDAV("Error: Proxy-Configuration failed.");
-    } else if( proxystate > 0 ) {
-        ne_set_proxy_auth( dav_session.ctx, ne_proxy_auth, 0 );
-    }
-
-    _connected = 1;
-    rc = 0;
-out:
-    SAFE_FREE(path);
-    SAFE_FREE(host);
-    SAFE_FREE(scheme);
-    return rc;
-}
-
-/*
- * result parsing list.
- * This function is called to parse the result of the propfind request
- * to list directories on the WebDAV server. I takes a single resource
- * and fills a resource struct and stores it to the result list which
- * is stored in the listdir_context.
- */
-static void results(void *userdata,
-                    const ne_uri *uri,
-                    const ne_prop_result_set *set)
-{
-    struct listdir_context *fetchCtx = userdata;
-    struct resource *newres = 0;
-    const char *clength, *modtime = NULL;
-    const char *resourcetype = NULL;
-    const char *md5sum = NULL;
-    const char *file_id = NULL;
-    const ne_status *status = NULL;
-    char *path = ne_path_unescape( uri->path );
-
-    (void) status;
-    if( ! fetchCtx ) {
-        DEBUG_WEBDAV("No valid fetchContext");
-        return;
-    }
-
-    if( ! fetchCtx->target ) {
-        DEBUG_WEBDAV("error: target must not be zero!" );
-        return;
-    }
-
-    /* Fill the resource structure with the data about the file */
-    newres = c_malloc(sizeof(struct resource));
-    newres->uri =  path; /* no need to strdup because ne_path_unescape already allocates */
-    newres->name = c_basename( path );
-
-    modtime      = ne_propset_value( set, &ls_props[0] );
-    clength      = ne_propset_value( set, &ls_props[1] );
-    resourcetype = ne_propset_value( set, &ls_props[2] );
-    md5sum       = ne_propset_value( set, &ls_props[3] );
-    file_id      = ne_propset_value( set, &ls_props[4] );
-
-    newres->type = resr_normal;
-    if( clength == NULL && resourcetype && strncmp( resourcetype, "<DAV:collection>", 16 ) == 0) {
-        newres->type = resr_collection;
-    }
-
-    if (modtime) {
-        newres->modtime = oc_httpdate_parse(modtime);
-    }
-
-    /* DEBUG_WEBDAV("Parsing Modtime: %s -> %llu", modtime, (unsigned long long) newres->modtime ); */
-    newres->size = 0;
-    if (clength) {
-        newres->size = atoll(clength);
-        /* DEBUG_WEBDAV("Parsed File size for %s from %s: %lld", newres->name, clength, (long long)newres->size ); */
-    }
-
-    if( md5sum ) {
-        int len = strlen(md5sum)-2;
-        if( len > 0 ) {
-            /* Skip the " around the string coming back from the ne_propset_value call */
-            newres->md5 = c_malloc(len+1);
-            strncpy( newres->md5, md5sum+1, len );
-            newres->md5[len] = '\0';
-        }
-    }
-
-    csync_vio_set_file_id(newres->file_id, file_id);
-
-    /* prepend the new resource to the result list */
-    newres->next   = fetchCtx->list;
-    fetchCtx->list = newres;
-    fetchCtx->result_count = fetchCtx->result_count + 1;
-    /* DEBUG_WEBDAV( "results for URI %s: %d %d", newres->name, (int)newres->size, (int)newres->type ); */
-}
-
-
-
-/*
- * fetches a resource list from the WebDAV server. This is equivalent to list dir.
- */
-static struct listdir_context *fetch_resource_list(const char *uri, int depth)
-{
-    struct listdir_context *fetchCtx;
-    int ret = 0;
-    ne_propfind_handler *hdl = NULL;
-    ne_request *request = NULL;
-    const char *content_type = NULL;
-    char *curi = NULL;
-    const ne_status *req_status = NULL;
-
-    curi = _cleanPath( uri );
-
-    /* The old legacy one-level PROPFIND cache. Also gets filled
-       by the recursive cache if 'infinity' did not suceed. */
-    if (propfind_cache) {
-        if (c_streq(curi, propfind_cache->target)) {
-            DEBUG_WEBDAV("fetch_resource_list Using simple PROPFIND cache %s", curi);
-            propfind_cache->ref++;
-            SAFE_FREE(curi);
-            return propfind_cache;
-        }
-    }
-
-    fetchCtx = c_malloc( sizeof( struct listdir_context ));
-    if (!fetchCtx) {
-        errno = ENOMEM;
-        SAFE_FREE(curi);
-        return NULL;
-    }
-    fetchCtx->list = NULL;
-    fetchCtx->target = curi;
-    fetchCtx->currResource = NULL;
-    fetchCtx->ref = 1;
-
-    /* do a propfind request and parse the results in the results function, set as callback */
-    hdl = ne_propfind_create(dav_session.ctx, curi, depth);
-
-    if(hdl) {
-        ret = ne_propfind_named(hdl, ls_props, results, fetchCtx);
-        request = ne_propfind_get_request( hdl );
-        req_status = ne_get_status( request );
-    }
-
-    if( ret == NE_OK ) {
-        fetchCtx->currResource = fetchCtx->list;
-        /* Check the request status. */
-        if( req_status && req_status->klass != 2 ) {
-            set_errno_from_http_errcode(req_status->code);
-            DEBUG_WEBDAV("ERROR: Request failed: status %d (%s)", req_status->code,
-                         req_status->reason_phrase);
-            ret = NE_CONNECT;
-            set_error_message(req_status->reason_phrase);
-            oc_notify_progress( uri, CSYNC_NOTIFY_ERROR,
-                                req_status->code,
-                                (intptr_t)(req_status->reason_phrase) );
-        }
-        DEBUG_WEBDAV("Simple propfind result code %d.", req_status->code);
-    } else {
-        if( ret == NE_ERROR && req_status->code == 404) {
-            errno = ENOENT;
-        } else {
-            set_errno_from_neon_errcode(ret);
-        }
-    }
-
-    if( ret == NE_OK ) {
-        /* Check the content type. If the server has a problem, ie. database is gone or such,
-         * the content type is not xml but a html error message. Stop on processing if it's
-         * not XML.
-         * FIXME: Generate user error message from the reply content.
-         */
-        content_type =  ne_get_response_header( request, "Content-Type" );
-        if( !(content_type && c_streq(content_type, "application/xml; charset=utf-8") ) ) {
-            DEBUG_WEBDAV("ERROR: Content type of propfind request not XML: %s.",
-                         content_type ?  content_type: "<empty>");
-            errno = ERRNO_WRONG_CONTENT;
-            set_error_message("Server error: PROPFIND reply is not XML formatted!");
-            ret = NE_CONNECT;
-        }
-    }
-
-    if( ret != NE_OK ) {
-        const char *err = NULL;
-
-        err = ne_get_error( dav_session.ctx );
-        DEBUG_WEBDAV("WRN: propfind named failed with %d, request error: %s", ret, err ? err : "<nil>");
-    }
-
-    if( hdl )
-        ne_propfind_destroy(hdl);
-
-    if( ret != NE_OK ) {
-        free_fetchCtx(fetchCtx);
-        return NULL;
-    }
-
-    free_fetchCtx(propfind_cache);
-    propfind_cache = fetchCtx;
-    propfind_cache->ref++;
-    return fetchCtx;
-}
-
-static struct listdir_context *fetch_resource_list_attempts(const char *uri, int depth)
-{
-    int i;
-
-    struct listdir_context *fetchCtx = NULL;
-    for(i = 0; i < 10; ++i) {
-        fetchCtx = fetch_resource_list(uri, depth);
-        if(fetchCtx) break;
-        /* only loop in case the content is not XML formatted. Otherwise for every
-         * non successful stat (for non existing directories) its tried 10 times. */
-        if( errno != ERRNO_WRONG_CONTENT ) break;
-
-        DEBUG_WEBDAV("=> Errno after fetch resource list for %s: %d", uri, errno);
-        DEBUG_WEBDAV("   New attempt %i", i);
-    }
-    return fetchCtx;
-}
-
-static void fill_stat_cache( csync_vio_file_stat_t *lfs ) {
-
-    if( _stat_cache.name ) SAFE_FREE(_stat_cache.name);
-    if( _stat_cache.etag  ) SAFE_FREE(_stat_cache.etag );
-
-    if( !lfs) return;
-
-    _stat_cache.name   = c_strdup(lfs->name);
-    _stat_cache.mtime  = lfs->mtime;
-    _stat_cache.fields = lfs->fields;
-    _stat_cache.type   = lfs->type;
-    _stat_cache.size   = lfs->size;
-    csync_vio_file_stat_set_file_id(&_stat_cache, lfs->file_id);
-
-    if( lfs->etag ) {
-        _stat_cache.etag    = c_strdup(lfs->etag);
-    }
-}
-
-
-
-/*
- * file functions
- */
-static int owncloud_stat(const char *uri, csync_vio_file_stat_t *buf) {
-    /* get props:
-     *   modtime
-     *   creattime
-     *   size
-     */
-    csync_vio_file_stat_t *lfs = NULL;
-    struct listdir_context  *fetchCtx = NULL;
-    char *decodedUri = NULL;
-    int len = 0;
-    errno = 0;
-
-    DEBUG_WEBDAV("owncloud_stat %s called", uri );
-
-    buf->name = c_basename(uri);
-
-    if (buf->name == NULL) {
-        errno = ENOMEM;
-        return -1;
-    }
-
-    if( _stat_cache.name && strcmp( buf->name, _stat_cache.name ) == 0 ) {
-        buf->fields  = CSYNC_VIO_FILE_STAT_FIELDS_NONE;
-        buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_TYPE;
-        buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_SIZE;
-        buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_MTIME;
-        buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_PERMISSIONS;
-        buf->fields  = _stat_cache.fields;
-        buf->type    = _stat_cache.type;
-        buf->mtime   = _stat_cache.mtime;
-        buf->size    = _stat_cache.size;
-        buf->mode    = _stat_perms( _stat_cache.type );
-        buf->etag     = NULL;
-        if( _stat_cache.etag ) {
-            buf->etag    = c_strdup( _stat_cache.etag );
-            buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_ETAG;
-        }
-        csync_vio_file_stat_set_file_id( buf, _stat_cache.file_id );
-        return 0;
-    }
-    DEBUG_WEBDAV("owncloud_stat => Could not find in stat cache %s", uri);
-
-    /* fetch data via a propfind call. */
-    /* fetchCtx = fetch_resource_list( uri, NE_DEPTH_ONE); */
-    fetchCtx = fetch_resource_list_attempts( uri, NE_DEPTH_ONE);
-    DEBUG_WEBDAV("=> Errno after fetch resource list for %s: %d", uri, errno);
-    if (!fetchCtx) {
-        return -1;
-    }
-
-    if( fetchCtx ) {
-        struct resource *res = fetchCtx->list;
-        while( res ) {
-            /* remove trailing slashes */
-            len = strlen(res->uri);
-            while( len > 0 && res->uri[len-1] == '/' ) --len;
-            decodedUri = ne_path_unescape( fetchCtx->target ); /* allocates memory */
-
-            /* Only do the comparaison of the part of the string without the trailing
-               slashes, and make sure decodedUri is not too large */
-            if( strncmp(res->uri, decodedUri, len ) == 0 && decodedUri[len] == '\0') {
-                SAFE_FREE( decodedUri );
-                break;
-            }
-            res = res->next;
-            SAFE_FREE( decodedUri );
-        }
-        if( res ) {
-            DEBUG_WEBDAV("Working on file %s", res->name );
-        } else {
-            DEBUG_WEBDAV("ERROR: Result struct not valid!");
-        }
-
-        lfs = resourceToFileStat( res );
-        if( lfs ) {
-            buf->fields = CSYNC_VIO_FILE_STAT_FIELDS_NONE;
-            buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_TYPE;
-            buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_SIZE;
-            buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_MTIME;
-            buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_PERMISSIONS;
-            buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_ETAG;
-
-            buf->fields = lfs->fields;
-            buf->type   = lfs->type;
-            buf->mtime  = lfs->mtime;
-            buf->size   = lfs->size;
-            buf->mode   = _stat_perms( lfs->type );
-            buf->etag    = NULL;
-            if( lfs->etag ) {
-                buf->etag    = c_strdup( lfs->etag );
-            }
-            csync_vio_file_stat_set_file_id( buf, lfs->file_id );
-
-            /* fill the static stat buf as input for the stat function */
-            csync_vio_file_stat_destroy( lfs );
-        }
-
-        free_fetchCtx( fetchCtx );
-    }
-    DEBUG_WEBDAV("STAT result from propfind: %s, mtime: %llu", buf->name ? buf->name:"NULL",
-                    (unsigned long long) buf->mtime );
-
-    return 0;
-}
-
-/* capabilities are currently:
- *  bool atomar_copy_support - oC provides atomar copy
- *  bool do_post_copy_stat   - oC does not want the post copy check
- *  bool time_sync_required  - oC does not require the time sync
- *  int  unix_extensions     - oC supports unix extensions.
- *  bool propagate_on_fd     - oC supports the send_file method.
- */
-static csync_vio_capabilities_t _owncloud_capabilities = { true, false, false, 0, true, false, false };
-
-static csync_vio_capabilities_t *owncloud_capabilities(void)
-{
-#ifdef _WIN32
-  _owncloud_capabilities.unix_extensions = 0;
-#endif
-  return &_owncloud_capabilities;
-}
-
-static const char* owncloud_get_etag( const char *path )
-{
-    ne_request *req    = NULL;
-    const char *header = NULL;
-    char *uri          = _cleanPath(path);
-    char *buf          = NULL;
-    const char *cbuf   = NULL;
-    csync_vio_file_stat_t *fs = NULL;
-    bool doHeadRequest = false;
-
-    if (_id_cache.uri && c_streq(path, _id_cache.uri)) {
-        header = _id_cache.id;
-    }
-
-    doHeadRequest= false; /* ownCloud server doesn't have good support for HEAD yet */
-
-    if( !header && doHeadRequest ) {
-        int neon_stat;
-        /* Perform an HEAD request to the resource. HEAD delivers the
-         * ETag header back. */
-        req = ne_request_create(dav_session.ctx, "HEAD", uri);
-        neon_stat = ne_request_dispatch(req);
-        set_errno_from_neon_errcode( neon_stat );
-
-        header = ne_get_response_header(req, "etag");
-    }
-    /* If the request went wrong or the server did not respond correctly
-     * (that can happen for collections) a stat call is done which translates
-     * into a PROPFIND request.
-     */
-    if( ! header ) {
-        /* ... and do a stat call. */
-        fs = csync_vio_file_stat_new();
-        if(fs == NULL) {
-            DEBUG_WEBDAV( "owncloud_get_etag: memory fault.");
-            errno = ENOMEM;
-            return NULL;
-        }
-        if( owncloud_stat( path, fs ) == 0 ) {
-            header = fs->etag;
-        }
-    }
-
-    /* In case the result is surrounded by "" cut them away. */
-    if( header ) {
-        if( header [0] == '"' && header[ strlen(header)-1] == '"') {
-            int len = strlen( header )-2;
-            buf = c_malloc( len+1 );
-            strncpy( buf, header+1, len );
-            buf[len] = '\0';
-            cbuf = buf;
-            /* do not free header here, as it belongs to the request */
-        } else {
-            cbuf = c_strdup(header);
-        }
-    }
-
-    /* fix server problem: If we end up with an empty string, set something strange... */
-    if( c_streq(cbuf, "") || c_streq(cbuf, "\"\"") ) {
-        SAFE_FREE(cbuf);
-        cbuf = c_strdup("empty_etag");
-    }
-
-    DEBUG_WEBDAV("Get file ID for %s: %s", path, cbuf ? cbuf:"<null>");
-    if( fs ) csync_vio_file_stat_destroy(fs);
-    if( req ) ne_request_destroy(req);
-    SAFE_FREE(uri);
-
-    return cbuf;
-}
-
-/*
- * directory functions
- */
-static csync_vio_method_handle_t *owncloud_opendir(const char *uri) {
-    struct listdir_context *fetchCtx = NULL;
-    char *curi = NULL;
-
-    DEBUG_WEBDAV("opendir method called on %s", uri );
-
-    dav_connect( uri );
-
-    curi = _cleanPath( uri );
-    if (is_first_propfind && !dav_session.no_recursive_propfind) {
-        is_first_propfind = false;
-        // Try to fill it
-        fill_recursive_propfind_cache(uri, curi);
-    }
-    if (propfind_recursive_cache) {
-        // Try to fetch from recursive cache (if we have one)
-        fetchCtx = get_listdir_context_from_recursive_cache(curi);
-    }
-    SAFE_FREE(curi);
-    is_first_propfind = false;
-    if (fetchCtx) {
-        return fetchCtx;
-    }
-
-    /* fetchCtx = fetch_resource_list( uri, NE_DEPTH_ONE ); */
-    fetchCtx = fetch_resource_list_attempts( uri, NE_DEPTH_ONE);
-    if( !fetchCtx ) {
-        /* errno is set properly in fetch_resource_list */
-        DEBUG_WEBDAV("Errno set to %d", errno);
-        return NULL;
-    } else {
-        fetchCtx->currResource = fetchCtx->list;
-        DEBUG_WEBDAV("opendir returning handle %p (count=%d)", (void*) fetchCtx, fetchCtx->result_count );
-        return fetchCtx;
-    }
-    /* no freeing of curi because its part of the fetchCtx and gets freed later */
-}
-
-static int owncloud_closedir(csync_vio_method_handle_t *dhandle) {
-
-    struct listdir_context *fetchCtx = dhandle;
-
-    DEBUG_WEBDAV("closedir method called %p!", dhandle);
-
-    free_fetchCtx(fetchCtx);
-
-    return 0;
-}
-
-static csync_vio_file_stat_t *owncloud_readdir(csync_vio_method_handle_t *dhandle) {
-
-    struct listdir_context *fetchCtx = dhandle;
-
-    if( fetchCtx == NULL) {
-        /* DEBUG_WEBDAV("An empty dir or at end"); */
-        return NULL;
-    }
-
-    while( fetchCtx->currResource ) {
-        resource* currResource = fetchCtx->currResource;
-        char *escaped_path = NULL;
-
-        /* set pointer to next element */
-        fetchCtx->currResource = fetchCtx->currResource->next;
-
-        /* It seems strange: first uri->path is unescaped to escape it in the next step again.
-         * The reason is that uri->path is not completely escaped (ie. it seems only to have
-         * spaces escaped), while the fetchCtx->target is fully escaped.
-         * See http://bugs.owncloud.org/thebuggenie/owncloud/issues/oc-613
-         */
-        escaped_path = ne_path_escape( currResource->uri );
-        if (ne_path_compare(fetchCtx->target, escaped_path) != 0) {
-            csync_vio_file_stat_t* lfs = resourceToFileStat(currResource);
-            fill_stat_cache(lfs);
-            SAFE_FREE( escaped_path );
-            return lfs;
-        }
-
-        /* This is the target URI */
-        SAFE_FREE( escaped_path );
-    }
-
-    return NULL;
-}
-
-static char *owncloud_error_string()
-{
-    return dav_session.error_string;
-}
-
-static int owncloud_commit() {
-
-  clean_caches();
-
-  if( dav_session.ctx )
-    ne_session_destroy( dav_session.ctx );
-  /* DEBUG_WEBDAV( "********** vio_module_shutdown" ); */
-
-  dav_session.ctx = 0;
-
-  // ne_sock_exit();
-  _connected = 0;  /* triggers dav_connect to go through the whole neon setup */
-
-  SAFE_FREE( dav_session.user );
-  SAFE_FREE( dav_session.pwd );
-  SAFE_FREE( dav_session.session_key);
-  SAFE_FREE( dav_session.error_string );
-
-  SAFE_FREE( dav_session.proxy_type );
-  SAFE_FREE( dav_session.proxy_host );
-  SAFE_FREE( dav_session.proxy_user );
-  SAFE_FREE( dav_session.proxy_pwd  );
-
-  return 0;
-}
-
-static int owncloud_set_property(const char *key, void *data) {
-#define READ_STRING_PROPERTY(P) \
-    if (c_streq(key, #P)) { \
-        SAFE_FREE(dav_session.P); \
-        dav_session.P = c_strdup((const char*)data); \
-        return 0; \
-    }
-    READ_STRING_PROPERTY(session_key)
-    READ_STRING_PROPERTY(proxy_type)
-    READ_STRING_PROPERTY(proxy_host)
-    READ_STRING_PROPERTY(proxy_user)
-    READ_STRING_PROPERTY(proxy_pwd)
-#undef READ_STRING_PROPERTY
-
-    if (c_streq(key, "proxy_port")) {
-        dav_session.proxy_port = *(int*)(data);
-        return 0;
-    }
-    if (c_streq(key, "read_timeout") || c_streq(key, "timeout")) {
-        dav_session.read_timeout = *(int*)(data);
-        return 0;
-    }
-    if( c_streq(key, "csync_context")) {
-        dav_session.csync_ctx = data;
-        return 0;
-    }
-    if( c_streq(key, "hbf_info")) {
-        dav_session.chunk_info = (csync_hbf_info_t *)(data);
-        return 0;
-    }
-    if( c_streq(key, "get_dav_session")) {
-        /* Give the ne_session to the caller */
-        *(ne_session**)data = dav_session.ctx;
-        return 0;
-    }
-    if( c_streq(key, "no_recursive_propfind")) {
-        dav_session.no_recursive_propfind = *(bool*)(data);
-        return 0;
-    }
-    if( c_streq(key, "hbf_block_size")) {
-        dav_session.hbf_block_size = *(int64_t*)(data);
-        return 0;
-    }
-    if( c_streq(key, "hbf_threshold")) {
-        dav_session.hbf_threshold = *(int64_t*)(data);
-        return 0;
-    }
-    if( c_streq(key, "bandwidth_limit_upload")) {
-        dav_session.bandwidth_limit_upload = *(int*)(data);
-        return 0;
-    }
-    if( c_streq(key, "bandwidth_limit_download")) {
-        dav_session.bandwidth_limit_download = *(int*)(data);
-        return 0;
-    }
-    if( c_streq(key, "overall_progress_data")) {
-      dav_session.overall_progress_data = (csync_overall_progress_t*)(data);
-    }
-    if( c_streq(key, "redirect_callback")) {
-        if (data) {
-            csync_owncloud_redirect_callback_t* cb_wrapper = data;
-
-            dav_session.redir_callback = *cb_wrapper;
-        } else {
-            dav_session.redir_callback = NULL;
-        }
-    }
-
-    return -1;
-}
-
-csync_vio_method_t _method = {
-    .method_table_size = sizeof(csync_vio_method_t),
-    .get_capabilities = owncloud_capabilities,
-    .get_etag = owncloud_get_etag,
-    .open = 0,
-    .creat = 0,
-    .close = 0,
-    .read = 0,
-    .write = 0,
-    .sendfile = 0,
-    .lseek = 0,
-    .opendir = owncloud_opendir,
-    .closedir = owncloud_closedir,
-    .readdir = owncloud_readdir,
-    .mkdir = 0,
-    .rmdir = 0,
-    .stat = owncloud_stat,
-    .rename = 0,
-    .unlink = 0,
-    .chmod = 0,
-    .chown = 0,
-    .utimes = 0,
-    .set_property = owncloud_set_property,
-    .get_error_string = owncloud_error_string,
-    .commit = owncloud_commit
-
-};
-
-csync_vio_method_t *vio_module_init(const char *method_name, const char *args,
-                                    csync_auth_callback cb, void *userdata) {
-    (void) method_name;
-    (void) args;
-    (void) userdata;
-
-    _authcb = cb;
-    _connected = 0;  /* triggers dav_connect to go through the whole neon setup */
-
-    memset(&dav_session, 0, sizeof(dav_session));
-
-    /* Disable it, Mirall can enable it for the first sync (= no DB)*/
-    dav_session.no_recursive_propfind = true;
-
-    return &_method;
-}
-
-void vio_module_shutdown(csync_vio_method_t *method) {
-    (void) method;
-
-    /* DEBUG_WEBDAV( "********** vio_module_shutdown" ); */
-}
-
-/* vim: set ts=4 sw=4 et cindent: */
diff --git a/modules/csync_owncloud.h b/modules/csync_owncloud.h
deleted file mode 100644
index 244e1b6..0000000
--- a/modules/csync_owncloud.h
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * libcsync -- a library to sync a directory with another
- *
- * Copyright (c) 2011      by Andreas Schneider <asn@cryptomilk.org>
- * Copyright (c) 2012      by Klaas Freitag <freitag@owncloud.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-#ifndef CSYNC_OWNCLOUD_H
-#define CSYNC_OWNCLOUD_H
-
-#include <errno.h>
-#include <stdio.h>
-#include <time.h>
-#include <limits.h>
-#include <stdlib.h>
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-
-#include "config.h"
-#ifdef NEON_WITH_LFS /* Switch on LFS in libneon. Never remove the NE_LFS! */
-#define NE_LFS
-#endif
-
-#include <neon/ne_basic.h>
-#include <neon/ne_socket.h>
-#include <neon/ne_session.h>
-#include <neon/ne_request.h>
-#include <neon/ne_props.h>
-#include <neon/ne_auth.h>
-#include <neon/ne_dates.h>
-#include <neon/ne_compress.h>
-#include <neon/ne_redirect.h>
-
-
-#include "c_rbtree.h"
-
-#include "c_lib.h"
-#include "csync.h"
-#include "csync_misc.h"
-#include "csync_macros.h"
-#include "c_private.h"
-#include "httpbf.h"
-
-#include "vio/csync_vio_module.h"
-#include "vio/csync_vio_file_stat.h"
-#include "vio/csync_vio.h"
-
-#include "csync_log.h"
-
-
-#define DEBUG_WEBDAV(...) csync_log( 9, "oc_module", __VA_ARGS__);
-
-enum resource_type {
-    resr_normal = 0,
-    resr_collection,
-    resr_reference,
-    resr_error
-};
-
-/* Struct to store data for each resource found during an opendir operation.
- * It represents a single file entry.
- */
-
-typedef struct resource {
-    char *uri;           /* The complete uri */
-    char *name;          /* The filename only */
-
-    enum resource_type type;
-    int64_t              size;
-    time_t             modtime;
-    char*              md5;
-    char               file_id[FILE_ID_BUF_SIZE+1];
-
-    struct resource    *next;
-} resource;
-
-/* Struct to hold the context of a WebDAV PropFind operation to fetch
- * a directory listing from the server.
- */
-struct listdir_context {
-    struct resource *list;           /* The list of result resources */
-    struct resource *currResource;   /* A pointer to the current resource */
-    char            *target;        /* Request-URI of the PROPFIND */
-    unsigned int     result_count;   /* number of elements stored in list */
-    int ref; /* reference count, only destroy when it reaches 0 */
-};
-
-
-/* Our cache, key is a char* */
-extern c_rbtree_t *propfind_recursive_cache;
-/* Values are propfind_recursive_element: */
-struct propfind_recursive_element {
-    struct resource *self;
-    struct resource *children;
-    struct propfind_recursive_element *parent;
-};
-typedef struct propfind_recursive_element propfind_recursive_element_t;
-void clear_propfind_recursive_cache(void);
-struct listdir_context *get_listdir_context_from_recursive_cache(const char *curi);
-void fill_recursive_propfind_cache(const char *uri, const char *curi);
-struct listdir_context *get_listdir_context_from_cache(const char *curi);
-void fetch_resource_list_recursive(const char *uri, const char *curi);
-
-typedef int (*csync_owncloud_redirect_callback_t)(CSYNC* ctx, const char* uri);
-
-/* Struct with the WebDAV session */
-struct dav_session_s {
-    ne_session *ctx;
-    char *user;
-    char *pwd;
-
-    char *proxy_type;
-    char *proxy_host;
-    int   proxy_port;
-    char *proxy_user;
-    char *proxy_pwd;
-
-    char *session_key;
-
-    char *error_string;
-
-    int read_timeout;
-
-    CSYNC *csync_ctx;
-
-    csync_hbf_info_t *chunk_info;
-
-    bool no_recursive_propfind;
-    int64_t hbf_block_size;
-    int64_t hbf_threshold;
-
-    /* If 0, it is disabled.   If >0,  in Byte/seconds. If < 0,  in % of the available bandwidth*/
-    int bandwidth_limit_upload;
-    int bandwidth_limit_download;
-
-    csync_overall_progress_t *overall_progress_data;
-    csync_owncloud_redirect_callback_t redir_callback;
-};
-extern struct dav_session_s dav_session;
-
-/* The list of properties that is fetched in PropFind on a collection */
-static const ne_propname ls_props[] = {
-    { "DAV:", "getlastmodified" },
-    { "DAV:", "getcontentlength" },
-    { "DAV:", "resourcetype" },
-    { "DAV:", "getetag"},
-    { "http://owncloud.org/ns", "id"},
-    { NULL, NULL }
-};
-
-void set_errno_from_http_errcode( int err );
-void set_error_message( const char *msg );
-void set_errno_from_neon_errcode( int neon_code );
-int http_result_code_from_session(void);
-void set_errno_from_session(void);
-
-time_t oc_httpdate_parse( const char *date );
-
-char *_cleanPath( const char* uri );
-
-int _stat_perms( int type );
-csync_vio_file_stat_t *resourceToFileStat( struct resource *res );
-
-void oc_notify_progress(const char *file, enum csync_notify_type_e kind, int64_t current_size, int64_t full_size);
-
-#endif /* CSYNC_OWNCLOUD_H */
diff --git a/modules/csync_owncloud_recursive_propfind.c b/modules/csync_owncloud_recursive_propfind.c
deleted file mode 100644
index 9f1aa90..0000000
--- a/modules/csync_owncloud_recursive_propfind.c
+++ /dev/null
@@ -1,338 +0,0 @@
-/*
- * libcsync -- a library to sync a directory with another
- *
- * Copyright (c) 2011      by Andreas Schneider <asn@cryptomilk.org>
- * Copyright (c) 2012      by Klaas Freitag <freitag@owncloud.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "csync_owncloud.h"
-
-c_rbtree_t *propfind_recursive_cache = NULL;
-int propfind_recursive_cache_depth = 0;
-int propfind_recursive_cache_file_count = 0;
-int propfind_recursive_cache_folder_count = 0;
-
-
-static struct resource* resource_dup(struct resource* o) {
-    struct resource *r = c_malloc (sizeof( struct resource ));
-    r->uri = c_strdup(o->uri);
-    r->name = c_strdup(o->name);
-    r->type = o->type;
-    r->size = o->size;
-    r->modtime = o->modtime;
-    r->md5 = c_strdup(o->md5);
-    r->next = o->next;
-    csync_vio_set_file_id(r->file_id, o->file_id);
-
-    return r;
-}
-static void resource_free(struct resource* o) {
-    struct resource* old = NULL;
-    while (o)
-    {
-        old = o;
-        o = o->next;
-        SAFE_FREE(old->uri);
-        SAFE_FREE(old->name);
-        SAFE_FREE(old->md5);
-        SAFE_FREE(old);
-    }
-}
-
-static void _tree_destructor(void *data) {
-    propfind_recursive_element_t *element = data;
-    resource_free(element->self);
-    resource_free(element->children);
-    SAFE_FREE(element);
-}
-
-void clear_propfind_recursive_cache(void)
-{
-    if (propfind_recursive_cache) {
-        DEBUG_WEBDAV("clear_propfind_recursive_cache Invalidating..");
-        c_rbtree_destroy(propfind_recursive_cache, _tree_destructor);
-        propfind_recursive_cache = NULL;
-    }
-}
-
-struct listdir_context *get_listdir_context_from_recursive_cache(const char *curi)
-{
-    propfind_recursive_element_t *element = NULL;
-    struct listdir_context *fetchCtx = NULL;
-    struct resource *iterator, *r;
-
-    if (!propfind_recursive_cache) {
-        DEBUG_WEBDAV("get_listdir_context_from_recursive_cache No cache");
-        return NULL;
-    }
-
-    element = c_rbtree_node_data(c_rbtree_find(propfind_recursive_cache, curi));
-    if (!element) {
-        DEBUG_WEBDAV("get_listdir_context_from_recursive_cache No element %s in cache found", curi);
-        return NULL;
-    }
-
-    /* Out of the element, create a listdir_context.. if we could be sure that it is immutable, we could ref instead.. need to investigate */
-    fetchCtx = c_malloc( sizeof( struct listdir_context ));
-    fetchCtx->list = NULL;
-    fetchCtx->target = c_strdup(curi);
-    fetchCtx->currResource = NULL;
-    fetchCtx->ref = 1;
-
-    iterator = element->children;
-    r = NULL;
-    while (iterator) {
-        r = resource_dup(iterator);
-        r->next = fetchCtx->list;
-        fetchCtx->list = r;
-        iterator = iterator->next;
-        fetchCtx->result_count++;
-        /* DEBUG_WEBDAV("get_listdir_context_from_cache Returning cache for %s element %s", fetchCtx->target, fetchCtx->list->uri); */
-    }
-
-    r = resource_dup(element->self);
-    r->next = fetchCtx->list;
-    fetchCtx->result_count++;
-    fetchCtx->list = r;
-    fetchCtx->currResource = fetchCtx->list;
-    DEBUG_WEBDAV("get_listdir_context_from_cache Returning cache for %s (%d elements)", fetchCtx->target, fetchCtx->result_count);
-    return fetchCtx;
-}
-
-static int _key_cmp(const void *key, const void *b) {
-    const char *elementAUri = (char*)key;
-    const propfind_recursive_element_t *elementB = b;
-    return ne_path_compare(elementAUri, elementB->self->uri);
-}
-static int _data_cmp(const void *a, const void *b) {
-    const propfind_recursive_element_t *elementA = a;
-    const propfind_recursive_element_t *elementB = b;
-    return ne_path_compare(elementA->self->uri, elementB->self->uri);
-}
-static void propfind_results_recursive(void *userdata,
-                    const ne_uri *uri,
-                    const ne_prop_result_set *set)
-{
-    struct resource *newres = 0;
-    const char *clength, *modtime, *file_id = NULL;
-    const char *resourcetype = NULL;
-    const char *md5sum = NULL;
-    const ne_status *status = NULL;
-    char *path = ne_path_unescape( uri->path );
-    char *parentPath;
-    char *propfindRootUri = (char*) userdata;
-    propfind_recursive_element_t *element = NULL;
-    propfind_recursive_element_t *pElement = NULL;
-    int depth = 0;
-
-    (void) status;
-    (void) propfindRootUri;
-
-    if (!propfind_recursive_cache) {
-        c_rbtree_create(&propfind_recursive_cache, _key_cmp, _data_cmp);
-    }
-
-    /* Fill the resource structure with the data about the file */
-    newres = c_malloc(sizeof(struct resource));
-    newres->uri =  path; /* no need to strdup because ne_path_unescape already allocates */
-    newres->name = c_basename( path );
-
-    modtime      = ne_propset_value( set, &ls_props[0] );
-    clength      = ne_propset_value( set, &ls_props[1] );
-    resourcetype = ne_propset_value( set, &ls_props[2] );
-    md5sum       = ne_propset_value( set, &ls_props[3] );
-    file_id      = ne_propset_value( set, &ls_props[4] );
-
-    newres->type = resr_normal;
-    if( resourcetype && strncmp( resourcetype, "<DAV:collection>", 16 ) == 0) {
-        newres->type = resr_collection;
-        propfind_recursive_cache_folder_count++;
-    } else {
-        /* DEBUG_WEBDAV("propfind_results_recursive %s [%d]", newres->uri, newres->type); */
-        propfind_recursive_cache_file_count++;
-    }
-
-    if (modtime) {
-        newres->modtime = oc_httpdate_parse(modtime);
-    }
-
-    /* DEBUG_WEBDAV("Parsing Modtime: %s -> %llu", modtime, (unsigned long long) newres->modtime ); */
-    newres->size = 0;
-    if (clength) {
-        newres->size = atoll(clength);
-        /* DEBUG_WEBDAV("Parsed File size for %s from %s: %lld", newres->name, clength, (long long)newres->size ); */
-    }
-
-    if( md5sum ) {
-        int len = strlen(md5sum)-2;
-        if( len > 0 ) {
-            /* Skip the " around the string coming back from the ne_propset_value call */
-            newres->md5 = c_malloc(len+1);
-            strncpy( newres->md5, md5sum+1, len );
-            newres->md5[len] = '\0';
-        }
-    }
-
-    csync_vio_set_file_id(newres->file_id, file_id);
-    /*
-    DEBUG_WEBDAV("propfind_results_recursive %s [%s] %s", newres->uri, newres->type == resr_collection ? "collection" : "file", newres->md5);
-    */
-
-    /* Create new item in rb tree */
-    if (newres->type == resr_collection) {
-        DEBUG_WEBDAV("propfind_results_recursive %s is a folder", newres->uri);
-        /* Check if in rb tree */
-        element = c_rbtree_node_data(c_rbtree_find(propfind_recursive_cache,uri->path));
-        /* If not, create a new item and insert it */
-        if (!element) {
-            element = c_malloc(sizeof(propfind_recursive_element_t));
-            element->self = resource_dup(newres);
-            element->children = NULL;
-            element->parent = NULL;
-            c_rbtree_insert(propfind_recursive_cache, element);
-            /* DEBUG_WEBDAV("results_recursive Added collection %s", newres->uri); */
-        }
-    }
-
-    /* Check for parent in tree. If exists: Insert it into the children elements there */
-    parentPath = ne_path_parent(uri->path);
-    if (parentPath) {
-        propfind_recursive_element_t *parentElement = NULL;
-
-        parentElement = c_rbtree_node_data(c_rbtree_find(propfind_recursive_cache,parentPath));
-        free(parentPath);
-
-        if (parentElement) {
-            newres->next = parentElement->children;
-            parentElement->children = newres;
-
-            /* If the current result is a collection we also need to set its parent */
-            if (element)
-                element->parent = parentElement;
-
-            pElement = element;
-            while (pElement) {
-                depth++;
-                pElement = pElement->parent;
-            }
-            if (depth > propfind_recursive_cache_depth) {
-                DEBUG_WEBDAV("propfind_results_recursive %s new maximum tree depth %d", newres->uri, depth);
-                propfind_recursive_cache_depth = depth;
-            }
-
-            /* DEBUG_WEBDAV("results_recursive Added child %s to collection %s", newres->uri, element->self->uri); */
-        } else {
-            /* DEBUG_WEBDAV("results_recursive No parent %s found for child %s", parentPath, newres->uri); */
-            resource_free(newres);
-            newres = NULL;
-        }
-    }
-
-}
-
-void fetch_resource_list_recursive(const char *uri, const char *curi)
-{
-    int ret = 0;
-    ne_propfind_handler *hdl = NULL;
-    ne_request *request = NULL;
-    const char *content_type = NULL;
-    const ne_status *req_status = NULL;
-    int depth = NE_DEPTH_INFINITE;
-
-    DEBUG_WEBDAV("fetch_resource_list_recursive Starting recursive propfind %s %s", uri, curi);
-
-    /* do a propfind request and parse the results in the results function, set as callback */
-    hdl = ne_propfind_create(dav_session.ctx, curi, depth);
-
-    if(hdl) {
-        ret = ne_propfind_named(hdl, ls_props, propfind_results_recursive, (void*)curi);
-        request = ne_propfind_get_request( hdl );
-        req_status = ne_get_status( request );
-    }
-
-    if( ret == NE_OK ) {
-        /* Check the request status. */
-        if( req_status && req_status->klass != 2 ) {
-            set_errno_from_http_errcode(req_status->code);
-            DEBUG_WEBDAV("ERROR: Request failed: status %d (%s)", req_status->code,
-                         req_status->reason_phrase);
-            ret = NE_CONNECT;
-            set_error_message(req_status->reason_phrase);
-            oc_notify_progress(uri, CSYNC_NOTIFY_ERROR,  req_status->code, (intptr_t)(req_status->reason_phrase));
-        }
-        DEBUG_WEBDAV("Recursive propfind result code %d.", req_status ? req_status->code : 0);
-    } else {
-        if( ret == NE_ERROR && req_status->code == 404) {
-            errno = ENOENT;
-        } else {
-            set_errno_from_neon_errcode(ret);
-        }
-    }
-
-    if( ret == NE_OK ) {
-        /* Check the content type. If the server has a problem, ie. database is gone or such,
-         * the content type is not xml but a html error message. Stop on processing if it's
-         * not XML.
-         * FIXME: Generate user error message from the reply content.
-         */
-        content_type =  ne_get_response_header( request, "Content-Type" );
-        if( !(content_type && c_streq(content_type, "application/xml; charset=utf-8") ) ) {
-            DEBUG_WEBDAV("ERROR: Content type of propfind request not XML: %s.",
-                         content_type ?  content_type: "<empty>");
-            errno = ERRNO_WRONG_CONTENT;
-            set_error_message("Server error: PROPFIND reply is not XML formatted!");
-            ret = NE_CONNECT;
-        }
-    }
-
-    if( ret != NE_OK ) {
-        const char *err = NULL;
-
-        err = ne_get_error( dav_session.ctx );
-        DEBUG_WEBDAV("WRN: propfind named failed with %d, request error: %s", ret, err ? err : "<nil>");
-    }
-
-    if( hdl )
-        ne_propfind_destroy(hdl);
-
-    if( ret != NE_OK ) {
-        return;
-    }
-
-    return;
-}
-
-/* Called by owncloud_opendir()->fetch_resource_list() to fill the cache */
-extern struct listdir_context *propfind_cache;
-void fill_recursive_propfind_cache(const char *uri, const char *curi) {
-    fetch_resource_list_recursive(uri, curi);
-
-    if (propfind_recursive_cache_depth <= 2) {
-        DEBUG_WEBDAV("fill_recursive_propfind_cache %s Server maybe did not give us an 'infinity' depth result", curi);
-        /* transform the cache to the normal cache in propfind_cache */
-        propfind_cache = get_listdir_context_from_recursive_cache(curi);
-        /* clear the cache, it is bogus since the server returned only results for Depth 1 */
-        clear_propfind_recursive_cache();
-    } else {
-        DEBUG_WEBDAV("fill_recursive_propfind_cache %s We received %d elements deep for 'infinity' depth (%d folders, %d files)",
-                     curi,
-                     propfind_recursive_cache_depth,
-                     propfind_recursive_cache_folder_count,
-                     propfind_recursive_cache_file_count);
-
-    }
-}
diff --git a/modules/csync_owncloud_util.c b/modules/csync_owncloud_util.c
deleted file mode 100644
index 4d99055..0000000
--- a/modules/csync_owncloud_util.c
+++ /dev/null
@@ -1,364 +0,0 @@
-/*
- * libcsync -- a library to sync a directory with another
- *
- * Copyright (c) 2011      by Andreas Schneider <asn@cryptomilk.org>
- * Copyright (c) 2012      by Klaas Freitag <freitag@owncloud.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "csync_owncloud.h"
-#include "csync_misc.h"
-
-void set_error_message( const char *msg )
-{
-    SAFE_FREE(dav_session.error_string);
-    if( msg )
-        dav_session.error_string = c_strdup(msg);
-}
-
-void set_errno_from_http_errcode( int err ) {
-    int new_errno = 0;
-
-    switch(err) {
-    case 200:           /* OK */
-    case 201:           /* Created */
-    case 202:           /* Accepted */
-    case 203:           /* Non-Authoritative Information */
-    case 204:           /* No Content */
-    case 205:           /* Reset Content */
-    case 207:           /* Multi-Status */
-    case 304:           /* Not Modified */
-        new_errno = 0;
-        break;
-    case 401:           /* Unauthorized */
-    case 402:           /* Payment Required */
-    case 407:           /* Proxy Authentication Required */
-    case 405:
-        new_errno = EPERM;
-        break;
-    case 301:           /* Moved Permanently */
-    case 303:           /* See Other */
-    case 404:           /* Not Found */
-    case 410:           /* Gone */
-        new_errno = ENOENT;
-        break;
-    case 408:           /* Request Timeout */
-    case 504:           /* Gateway Timeout */
-        new_errno = EAGAIN;
-        break;
-    case 423:           /* Locked */
-        new_errno = EACCES;
-        break;
-    case 400:           /* Bad Request */
-    case 403:           /* Forbidden */
-    case 409:           /* Conflict */
-    case 411:           /* Length Required */
-    case 412:           /* Precondition Failed */
-    case 414:           /* Request-URI Too Long */
-    case 415:           /* Unsupported Media Type */
-    case 424:           /* Failed Dependency */
-    case 501:           /* Not Implemented */
-        new_errno = EINVAL;
-        break;
-    case 507:           /* Insufficient Storage */
-        new_errno = ENOSPC;
-        break;
-    case 206:           /* Partial Content */
-    case 300:           /* Multiple Choices */
-    case 302:           /* Found */
-    case 305:           /* Use Proxy */
-    case 306:           /* (Unused) */
-    case 307:           /* Temporary Redirect */
-    case 406:           /* Not Acceptable */
-    case 416:           /* Requested Range Not Satisfiable */
-    case 417:           /* Expectation Failed */
-    case 422:           /* Unprocessable Entity */
-    case 500:           /* Internal Server Error */
-    case 502:           /* Bad Gateway */
-    case 505:           /* HTTP Version Not Supported */
-        new_errno = EIO;
-        break;
-    case 503:           /* Service Unavailable */
-        new_errno = ERRNO_SERVICE_UNAVAILABLE;
-        break;
-    case 413:           /* Request Entity too Large */
-        new_errno = EFBIG;
-        break;
-    default:
-        new_errno = EIO;
-    }
-
-    errno = new_errno;
-}
-
-int http_result_code_from_session() {
-    const char *p = ne_get_error( dav_session.ctx );
-    char *q;
-    int err;
-
-    set_error_message(p); /* remember the error message */
-
-    err = strtol(p, &q, 10);
-    if (p == q) {
-        err = ERRNO_ERROR_STRING;
-    }
-    return err;
-}
-
-void set_errno_from_session() {
-    int err = http_result_code_from_session();
-
-    if( err == EIO || err == ERRNO_ERROR_STRING) {
-        errno = err;
-    } else {
-        set_errno_from_http_errcode(err);
-    }
-}
-
-void set_errno_from_neon_errcode( int neon_code ) {
-
-    if( neon_code != NE_OK ) {
-        DEBUG_WEBDAV("Neon error code was %d", neon_code);
-    }
-
-    switch(neon_code) {
-    case NE_OK:     /* Success, but still the possiblity of problems */
-    case NE_ERROR:  /* Generic error; use ne_get_error(session) for message */
-        set_errno_from_session(); /* Something wrong with http communication */
-        break;
-    case NE_LOOKUP:  /* Server or proxy hostname lookup failed */
-        errno = ERRNO_LOOKUP_ERROR;
-        break;
-    case NE_AUTH:     /* User authentication failed on server */
-        errno = ERRNO_USER_UNKNOWN_ON_SERVER;
-        break;
-    case NE_PROXYAUTH:  /* User authentication failed on proxy */
-        errno = ERRNO_PROXY_AUTH;
-        break;
-    case NE_CONNECT:  /* Could not connect to server */
-        errno = ERRNO_CONNECT;
-        break;
-    case NE_TIMEOUT:  /* Connection timed out */
-        errno = ERRNO_TIMEOUT;
-        break;
-    case NE_FAILED:   /* The precondition failed */
-        errno = ERRNO_PRECONDITION;
-        break;
-    case NE_RETRY:    /* Retry request (ne_end_request ONLY) */
-        errno = ERRNO_RETRY;
-        break;
-
-    case NE_REDIRECT: /* See ne_redirect.h */
-        errno = ERRNO_REDIRECT;
-        break;
-    default:
-        errno = ERRNO_GENERAL_ERROR;
-    }
-}
-
-/* cleanPath to return an escaped path of an uri */
-char *_cleanPath( const char* uri ) {
-    int rc = 0;
-    char *path = NULL;
-    char *re = NULL;
-
-    rc = c_parse_uri( uri, NULL, NULL, NULL, NULL, NULL, &path );
-    if( rc  < 0 ) {
-        DEBUG_WEBDAV("Unable to cleanPath %s", uri ? uri: "<zero>" );
-        re = NULL;
-    } else {
-        re = ne_path_escape( path );
-    }
-
-    SAFE_FREE( path );
-    return re;
-}
-
-
-#ifndef HAVE_TIMEGM
-#ifdef _WIN32
-static int is_leap(unsigned y) {
-    y += 1900;
-    return (y % 4) == 0 && ((y % 100) != 0 || (y % 400) == 0);
-}
-
-static time_t timegm(struct tm *tm) {
-    static const unsigned ndays[2][12] = {
-    {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
-    {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} };
-
-    time_t res = 0;
-    int i;
-
-    for (i = 70; i < tm->tm_year; ++i)
-        res += is_leap(i) ? 366 : 365;
-
-    for (i = 0; i < tm->tm_mon; ++i)
-        res += ndays[is_leap(tm->tm_year)][i];
-     res += tm->tm_mday - 1;
-     res *= 24;
-     res += tm->tm_hour;
-     res *= 60;
-     res += tm->tm_min;
-     res *= 60;
-     res += tm->tm_sec;
-     return res;
-}
-#else
-/* A hopefully portable version of timegm */
-static time_t timegm(struct tm *tm ) {
-     time_t ret;
-     char *tz;
-
-     tz = getenv("TZ");
-     setenv("TZ", "", 1);
-     tzset();
-     ret = mktime(tm);
-     if (tz)
-         setenv("TZ", tz, 1);
-     else
-         unsetenv("TZ");
-     tzset();
-     return ret;
-}
-#endif /* Platform switch */
-#endif /* HAVE_TIMEGM */
-
-#define RFC1123_FORMAT "%3s, %02d %3s %4d %02d:%02d:%02d GMT"
-static const char short_months[12][4] = {
-    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
-    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
-};
-/*
- * This function is borrowed from libneon's ne_httpdate_parse.
- * Unfortunately that one converts to local time but here UTC is
- * needed.
- * This one uses timegm instead, which returns UTC.
- */
-time_t oc_httpdate_parse( const char *date ) {
-    struct tm gmt;
-    char wkday[4], mon[4];
-    int n;
-    time_t result = 0;
-
-    memset(&gmt, 0, sizeof(struct tm));
-
-    /*  it goes: Sun, 06 Nov 1994 08:49:37 GMT */
-    n = sscanf(date, RFC1123_FORMAT,
-               wkday, &gmt.tm_mday, mon, &gmt.tm_year, &gmt.tm_hour,
-               &gmt.tm_min, &gmt.tm_sec);
-    /* Is it portable to check n==7 here? */
-    gmt.tm_year -= 1900;
-    for (n=0; n<12; n++)
-        if (strcmp(mon, short_months[n]) == 0)
-            break;
-    /* tm_mon comes out as 12 if the month is corrupt, which is desired,
-     * since the mktime will then fail */
-    gmt.tm_mon = n;
-    gmt.tm_isdst = -1;
-    result = timegm(&gmt);
-    return result;
-}
-
-
-/*
- * helper: convert a resource struct to file_stat struct.
- */
-csync_vio_file_stat_t *resourceToFileStat( struct resource *res )
-{
-    csync_vio_file_stat_t *lfs = NULL;
-
-    if( ! res ) {
-        return NULL;
-    }
-
-    lfs = c_malloc(sizeof(csync_vio_file_stat_t));
-    if (lfs == NULL) {
-        errno = ENOMEM;
-        return NULL;
-    }
-
-    lfs->name = c_strdup( res->name );
-
-    lfs->fields = CSYNC_VIO_FILE_STAT_FIELDS_NONE;
-    if( res->type == resr_normal ) {
-        lfs->fields |= CSYNC_VIO_FILE_STAT_FIELDS_TYPE;
-        lfs->type = CSYNC_VIO_FILE_TYPE_REGULAR;
-    } else if( res->type == resr_collection ) {
-        lfs->fields |= CSYNC_VIO_FILE_STAT_FIELDS_TYPE;
-        lfs->type = CSYNC_VIO_FILE_TYPE_DIRECTORY;
-    } else {
-        DEBUG_WEBDAV("ERROR: Unknown resource type %d", res->type);
-    }
-
-    lfs->mtime = res->modtime;
-    lfs->fields |= CSYNC_VIO_FILE_STAT_FIELDS_MTIME;
-    lfs->size  = res->size;
-    lfs->fields |= CSYNC_VIO_FILE_STAT_FIELDS_SIZE;
-    if( res->md5 ) {
-        lfs->etag   = c_strdup(res->md5);
-    }
-    lfs->fields |= CSYNC_VIO_FILE_STAT_FIELDS_ETAG;
-    csync_vio_file_stat_set_file_id(lfs, res->file_id);
-
-    return lfs;
-}
-
-/* WebDAV does not deliver permissions. Set a default here. */
-int _stat_perms( int type ) {
-    int ret = 0;
-
-    if( type == CSYNC_VIO_FILE_TYPE_DIRECTORY ) {
-        /* DEBUG_WEBDAV("Setting mode in stat (dir)"); */
-        /* directory permissions */
-        ret = S_IFDIR | S_IRUSR | S_IWUSR | S_IXUSR /* directory, rwx for user */
-                | S_IRGRP | S_IXGRP                       /* rx for group */
-                | S_IROTH | S_IXOTH;                      /* rx for others */
-    } else {
-        /* regualar file permissions */
-        /* DEBUG_WEBDAV("Setting mode in stat (file)"); */
-        ret = S_IFREG | S_IRUSR | S_IWUSR /* regular file, user read & write */
-                | S_IRGRP                         /* group read perm */
-                | S_IROTH;                        /* others read perm */
-    }
-    return ret;
-}
-
-void oc_notify_progress(const char *file, enum csync_notify_type_e kind, int64_t current_size, int64_t full_size)
-{
-  csync_progress_callback progress_cb = csync_get_progress_callback(dav_session.csync_ctx);
-
-  csync_overall_progress_t overall_progress;
-  ZERO_STRUCT(overall_progress);
-
-  if( dav_session.overall_progress_data) {
-    overall_progress = *dav_session.overall_progress_data;
-  }
-
-  if (progress_cb) {
-    CSYNC_PROGRESS progress;
-    progress.kind = kind;
-    progress.path = file;
-    progress.curr_bytes = current_size;
-    progress.file_size  = full_size;
-    progress.overall_transmission_size = overall_progress.byte_sum;
-    progress.current_overall_bytes     = overall_progress.byte_current+current_size;
-    progress.overall_file_count        = overall_progress.file_count;
-    progress.current_file_no           = overall_progress.current_file_no;
-
-    progress_cb(&progress, csync_get_userdata(dav_session.csync_ctx));
-  }
-}
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index e2df779..76c304f 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -12,6 +12,8 @@ else (CSYNC_STATIC_COMPILE_DIR)
     find_package(SQLite3 3.3.9 REQUIRED)
 endif()
 
+find_package(Neon 0.29.0 REQUIRED)
+
 
 set(CSYNC_PUBLIC_INCLUDE_DIRS
   ${CMAKE_CURRENT_BINARY_DIR}
@@ -23,6 +25,7 @@ set(CSYNC_PUBLIC_INCLUDE_DIRS
 set(CSYNC_PRIVATE_INCLUDE_DIRS
   ${SQLITE3_INCLUDE_DIRS}
   ${CSTDLIB_PUBLIC_INCLUDE_DIRS}
+  ${HTTPBF_PUBLIC_INCLUDE_DIRS}
   ${CMAKE_BINARY_DIR}
 )
 
@@ -36,6 +39,8 @@ set(CSYNC_LINK_LIBRARIES
   ${CSTDLIB_LIBRARY}
   ${CSYNC_REQUIRED_LIBRARIES}
   ${SQLITE3_LIBRARIES}
+  ${NEON_LIBRARIES}
+  ${HTTPBF_LIBRARY}
 )
 
 if(HAVE_ICONV AND WITH_ICONV)
@@ -71,6 +76,10 @@ set(csync_SRCS
   vio/csync_vio_handle.c
   vio/csync_vio_file_stat.c
   vio/csync_vio_local.c
+
+  csync_owncloud.c
+  csync_owncloud_recursive_propfind.c
+  csync_owncloud_util.c
 )
 
 configure_file(csync_version.h.in ${CMAKE_CURRENT_BINARY_DIR}/csync_version.h)
diff --git a/src/csync_owncloud.c b/src/csync_owncloud.c
new file mode 100644
index 0000000..1caf1fa
--- /dev/null
+++ b/src/csync_owncloud.c
@@ -0,0 +1,1224 @@
+/*
+ * libcsync -- a library to sync a directory with another
+ *
+ * Copyright (c) 2011      by Andreas Schneider <asn@cryptomilk.org>
+ * Copyright (c) 2012      by Klaas Freitag <freitag@owncloud.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "csync_owncloud.h"
+
+#include <inttypes.h>
+
+/*
+ * free the fetchCtx
+ */
+static void free_fetchCtx( struct listdir_context *ctx )
+{
+    struct resource *newres, *res;
+    if( ! ctx ) return;
+    newres = ctx->list;
+    res = newres;
+
+    ctx->ref--;
+    if (ctx->ref > 0) return;
+
+    SAFE_FREE(ctx->target);
+
+    while( res ) {
+        SAFE_FREE(res->uri);
+        SAFE_FREE(res->name);
+        SAFE_FREE(res->md5);
+        memset( res->file_id, 0, FILE_ID_BUF_SIZE+1 );
+
+        newres = res->next;
+        SAFE_FREE(res);
+        res = newres;
+    }
+    SAFE_FREE(ctx);
+}
+
+
+/*
+ * local variables.
+ */
+
+struct dav_session_s dav_session; /* The DAV Session, initialised in dav_connect */
+int _connected = 0;                   /* flag to indicate if a connection exists, ie.
+                                     the dav_session is valid */
+
+csync_auth_callback _authcb;
+long long chunked_total_size = 0;
+long long chunked_done = 0;
+
+struct listdir_context *propfind_cache = 0;
+
+bool is_first_propfind = true;
+
+
+csync_vio_file_stat_t _stat_cache;
+/* id cache, cache the ETag: header of a GET request */
+struct { char *uri; char *id;  } _id_cache = { NULL, NULL };
+
+static void clean_caches() {
+    clear_propfind_recursive_cache();
+
+    free_fetchCtx(propfind_cache);
+    propfind_cache = NULL;
+
+    SAFE_FREE(_stat_cache.name);
+    SAFE_FREE(_stat_cache.etag );
+    memset( _stat_cache.file_id, 0, FILE_ID_BUF_SIZE+1 );
+
+    SAFE_FREE(_id_cache.uri);
+    SAFE_FREE(_id_cache.id);
+}
+
+
+
+#define PUT_BUFFER_SIZE 1024*5
+
+char _buffer[PUT_BUFFER_SIZE];
+
+/*
+ * helper method to build up a user text for SSL problems, called from the
+ * verify_sslcert callback.
+ */
+static void addSSLWarning( char *ptr, const char *warn, int len )
+{
+    char *concatHere = ptr;
+    int remainingLen = 0;
+
+    if( ! (warn && ptr )) return;
+    remainingLen = len - strlen(ptr);
+    if( remainingLen <= 0 ) return;
+    concatHere = ptr + strlen(ptr);  /* put the write pointer to the end. */
+    strncpy( concatHere, warn, remainingLen );
+}
+
+/*
+ * Callback to verify the SSL certificate, called from libneon.
+ * It analyzes the SSL problem, creates a user information text and passes
+ * it to the csync callback to ask the user.
+ */
+#define LEN 4096
+static int verify_sslcert(void *userdata, int failures,
+                          const ne_ssl_certificate *certificate)
+{
+    char problem[LEN];
+    char buf[MAX(NE_SSL_DIGESTLEN, NE_ABUFSIZ)];
+    int ret = -1;
+    const ne_ssl_certificate *cert = certificate;
+
+    (void) userdata;
+    memset( problem, 0, LEN );
+
+    while( cert ) {
+
+      addSSLWarning( problem, "There are problems with the SSL certificate:\n", LEN );
+      if( failures & NE_SSL_NOTYETVALID ) {
+        addSSLWarning( problem, " * The certificate is not yet valid.\n", LEN );
+      }
+      if( failures & NE_SSL_EXPIRED ) {
+        addSSLWarning( problem, " * The certificate has expired.\n", LEN );
+      }
+
+      if( failures & NE_SSL_UNTRUSTED ) {
+        addSSLWarning( problem, " * The certificate is not trusted!\n", LEN );
+      }
+      if( failures & NE_SSL_IDMISMATCH ) {
+        addSSLWarning( problem, " * The hostname for which the certificate was "
+                       "issued does not match the hostname of the server\n", LEN );
+      }
+      if( failures & NE_SSL_BADCHAIN ) {
+        addSSLWarning( problem, " * The certificate chain contained a certificate other than the server cert\n", LEN );
+      }
+      if( failures & NE_SSL_REVOKED ) {
+        addSSLWarning( problem, " * The server certificate has been revoked by the issuing authority.\n", LEN );
+      }
+
+      if (ne_ssl_cert_digest(cert, buf) == 0) {
+        addSSLWarning( problem, "Certificate fingerprint: ", LEN );
+        addSSLWarning( problem, buf, LEN );
+        addSSLWarning( problem, "\n", LEN );
+      }
+      cert = ne_ssl_cert_signedby( cert );
+    }
+    addSSLWarning( problem, "Do you want to accept the certificate chain anyway?\nAnswer yes to do so and take the risk: ", LEN );
+
+    if( _authcb ){
+        /* call the csync callback */
+        DEBUG_WEBDAV("Call the csync callback for SSL problems");
+        memset( buf, 0, NE_ABUFSIZ );
+        (*_authcb) ( problem, buf, NE_ABUFSIZ-1, 1, 0, NULL );
+        if( buf[0] == 'y' || buf[0] == 'Y') {
+            ret = 0;
+        } else {
+            DEBUG_WEBDAV("Authentication callback replied %s", buf );
+
+        }
+    }
+    DEBUG_WEBDAV("## VERIFY_SSL CERT: %d", ret  );
+      return ret;
+}
+
+/*
+ * Authentication callback. Is set by ne_set_server_auth to be called
+ * from the neon lib to authenticate a request.
+ */
+static int ne_auth( void *userdata, const char *realm, int attempt,
+                    char *username, char *password)
+{
+    char buf[NE_ABUFSIZ];
+
+    (void) userdata;
+    (void) realm;
+
+    /* DEBUG_WEBDAV( "Authentication required %s", realm ); */
+    if( username && password ) {
+        DEBUG_WEBDAV( "Authentication required %s", username );
+        if( dav_session.user ) {
+            /* allow user without password */
+            if( strlen( dav_session.user ) < NE_ABUFSIZ ) {
+                strcpy( username, dav_session.user );
+            }
+            if( dav_session.pwd && strlen( dav_session.pwd ) < NE_ABUFSIZ ) {
+                strcpy( password, dav_session.pwd );
+            }
+        } else if( _authcb != NULL ){
+            /* call the csync callback */
+            DEBUG_WEBDAV("Call the csync callback for %s", realm );
+            memset( buf, 0, NE_ABUFSIZ );
+            (*_authcb) ("Enter your username: ", buf, NE_ABUFSIZ-1, 1, 0, NULL );
+            if( strlen(buf) < NE_ABUFSIZ ) {
+                strcpy( username, buf );
+            }
+            memset( buf, 0, NE_ABUFSIZ );
+            (*_authcb) ("Enter your password: ", buf, NE_ABUFSIZ-1, 0, 0, NULL );
+            if( strlen(buf) < NE_ABUFSIZ) {
+                strcpy( password, buf );
+            }
+        } else {
+            DEBUG_WEBDAV("I can not authenticate!");
+        }
+    }
+    return attempt;
+}
+
+/*
+ * Authentication callback. Is set by ne_set_proxy_auth to be called
+ * from the neon lib to authenticate against a proxy. The data to authenticate
+ * against comes from mirall throught vio_module_init function.
+ */
+static int ne_proxy_auth( void *userdata, const char *realm, int attempt,
+                          char *username, char *password)
+{
+    (void) userdata;
+    (void) realm;
+    if( dav_session.proxy_user && strlen( dav_session.proxy_user ) < NE_ABUFSIZ) {
+        strcpy( username, dav_session.proxy_user );
+        if( dav_session.proxy_pwd && strlen( dav_session.proxy_pwd ) < NE_ABUFSIZ) {
+            strcpy( password, dav_session.proxy_pwd );
+        }
+    }
+    /* NTLM needs several attempts */
+    return (attempt < 3) ? 0 : -1;
+}
+
+/* Configure the proxy depending on the variables */
+static int configureProxy( ne_session *session )
+{
+    int port = 8080;
+    int re = -1;
+
+    if( ! session ) return -1;
+    if( ! dav_session.proxy_type ) return 0; /* Go by NoProxy per default */
+
+    if( dav_session.proxy_port > 0 ) {
+        port = dav_session.proxy_port;
+    }
+
+    if( c_streq(dav_session.proxy_type, "NoProxy" )) {
+        DEBUG_WEBDAV("No proxy configured.");
+        re = 0;
+    } else if( c_streq(dav_session.proxy_type, "DefaultProxy") ||
+               c_streq(dav_session.proxy_type, "HttpProxy")    ||
+               c_streq(dav_session.proxy_type, "HttpCachingProxy") ||
+               c_streq(dav_session.proxy_type, "Socks5Proxy")) {
+
+        if( dav_session.proxy_host ) {
+            DEBUG_WEBDAV("%s at %s:%d", dav_session.proxy_type, dav_session.proxy_host, port );
+            if (c_streq(dav_session.proxy_type, "Socks5Proxy")) {
+                ne_session_socks_proxy(session, NE_SOCK_SOCKSV5, dav_session.proxy_host, port,
+                                       dav_session.proxy_user, dav_session.proxy_pwd);
+            } else {
+                ne_session_proxy(session, dav_session.proxy_host, port );
+            }
+            re = 2;
+        } else {
+            DEBUG_WEBDAV("%s requested but no proxy host defined.", dav_session.proxy_type );
+	    /* we used to try ne_system_session_proxy here, but we should rather err out
+	       to behave exactly like the caller. */
+        }
+    } else {
+        DEBUG_WEBDAV( "Unsupported Proxy: %s", dav_session.proxy_type );
+    }
+
+    return re;
+}
+
+/*
+ * This hook is called for with the response of a request. Here its checked
+ * if a Set-Cookie header is there for the PHPSESSID. The key is stored into
+ * the webdav session to be added to subsequent requests.
+ */
+static void post_request_hook(ne_request *req, void *userdata, const ne_status *status)
+{
+    const char *set_cookie_header = NULL;
+    const char *sc  = NULL;
+    char *key = NULL;
+
+    (void) userdata;
+
+    if (dav_session.session_key)
+        return; /* We already have a session cookie, and we should ignore other ones */
+
+    if(!(status && req)) return;
+    if( status->klass == 2 || status->code == 401 ) {
+        /* successful request */
+        set_cookie_header =  ne_get_response_header( req, "Set-Cookie" );
+        if( set_cookie_header ) {
+            DEBUG_WEBDAV(" Set-Cookie found: %s", set_cookie_header);
+            /* try to find a ', ' sequence which is the separator of neon if multiple Set-Cookie
+             * headers are there.
+             * The following code parses a string like this:
+             * Set-Cookie: 50ace6bd8a669=p537brtt048jh8srlp2tuep7em95nh9u98mj992fbqc47d1aecp1;
+             */
+            sc = set_cookie_header;
+            while(sc) {
+                const char *sc_val = sc;
+                const char *sc_end = sc_val;
+                int cnt = 0;
+                int len = strlen(sc_val); /* The length of the rest of the header string. */
+
+                while( cnt < len && *sc_end != ';' && *sc_end != ',') {
+                    cnt++;
+                    sc_end++;
+                }
+                if( cnt == len ) {
+                    /* exit: We are at the end. */
+                    sc = NULL;
+                } else if( *sc_end == ';' ) {
+                    /* We are at the end of the session key. */
+                    int keylen = sc_end-sc_val;
+                    if( key ) {
+                        int oldlen = strlen(key);
+                        key = c_realloc(key, oldlen + 2 + keylen+1);
+                        strcpy(key + oldlen, "; ");
+                        strncpy(key + oldlen + 2, sc_val, keylen);
+                        key[oldlen + 2 + keylen] = '\0';
+                    } else {
+                        key = c_malloc(keylen+1);
+                        strncpy( key, sc_val, keylen );
+                        key[keylen] = '\0';
+                    }
+
+                    /* now search for a ',' to find a potential other header entry */
+                    while(cnt < len && *sc_end != ',') {
+                        cnt++;
+                        sc_end++;
+                    }
+                    if( cnt < len )
+                        sc = sc_end+2; /* mind the space after the comma */
+                    else
+                        sc = NULL;
+                } else if( *sc_end == ',' ) {
+                    /* A new entry is to check. */
+                    if( *(sc_end + 1) == ' ') {
+                        sc = sc_end+2;
+                    } else {
+                        /* error condition */
+                        sc = NULL;
+                    }
+                }
+            }
+        }
+    } else {
+        DEBUG_WEBDAV("Request failed, don't take session header.");
+    }
+    if( key ) {
+        DEBUG_WEBDAV("----> Session-key: %s", key);
+        SAFE_FREE(dav_session.session_key);
+        dav_session.session_key = key;
+    }
+}
+
+/*
+ * this hook is called just after a request has been created, before its sent.
+ * Here it is used to set the proxy connection header if available.
+ */
+static void request_created_hook(ne_request *req, void *userdata,
+                                 const char *method, const char *requri)
+{
+    (void) userdata;
+    (void) method;
+    (void) requri;
+
+    if( !req ) return;
+
+    if(dav_session.proxy_type) {
+        /* required for NTLM */
+        ne_add_request_header(req, "Proxy-Connection", "Keep-Alive");
+    }
+}
+
+/*
+ * this hook is called just before a request has been sent.
+ * Here it is used to set the session cookie if available.
+ */
+static void pre_send_hook(ne_request *req, void *userdata,
+                          ne_buffer *header)
+{
+    (void) userdata;
+
+    if( !req ) return;
+
+    if(dav_session.session_key) {
+        ne_buffer_concat(header, "Cookie: ", dav_session.session_key, "\r\n", NULL);
+    }
+}
+
+static int post_send_hook(ne_request *req, void *userdata,
+                          const ne_status *status)
+{
+    const char *location;
+
+    (void) userdata;
+    (void) status;
+
+    location = ne_get_response_header(req, "Location");
+
+    if( !location ) return NE_OK;
+
+    if( dav_session.redir_callback ) {
+        if( dav_session.redir_callback( dav_session.csync_ctx, location ) ) {
+            return NE_REDIRECT;
+        } else {
+            return NE_RETRY;
+        }
+    }
+
+    return NE_REDIRECT;
+}
+
+// as per http://sourceforge.net/p/predef/wiki/OperatingSystems/
+// extend as required
+static const char* get_platform() {
+#if defined (_WIN32)
+    return "Windows";
+#elif defined(__APPLE__)
+    return "Macintosh";
+#elif defined(__gnu_linux__)
+    return "Linux";
+#elif defined(__DragonFly__)
+    /* might also define __FreeBSD__ */
+    return "DragonFlyBSD";
+#elif defined(__FreeBSD__)
+    return "FreeBSD";
+#elif defined(__NetBSD__)
+    return "NetBSD";
+#elif defined(__OpenBSD__)
+    return "OpenBSD";
+#elif defined(sun) || defined(__sun)
+    return "Solaris";
+#else
+    return "Unknown OS";
+#endif
+}
+
+/*
+ * Connect to a DAV server
+ * This function sets the flag _connected if the connection is established
+ * and returns if the flag is set, so calling it frequently is save.
+ */
+static int dav_connect(const char *base_url) {
+    int useSSL = 0;
+    int rc;
+    char protocol[6] = {'\0'};
+    char uaBuf[256];
+    char *path = NULL;
+    char *scheme = NULL;
+    char *host = NULL;
+    unsigned int port = 0;
+    int proxystate = -1;
+
+    if (_connected) {
+        return 0;
+    }
+
+    rc = c_parse_uri( base_url, &scheme, &dav_session.user, &dav_session.pwd, &host, &port, &path );
+    if( rc < 0 ) {
+        DEBUG_WEBDAV("Failed to parse uri %s", base_url );
+        goto out;
+    }
+
+    DEBUG_WEBDAV("* scheme %s", scheme );
+    DEBUG_WEBDAV("* host %s", host );
+    DEBUG_WEBDAV("* port %u", port );
+    DEBUG_WEBDAV("* path %s", path );
+
+    if( strcmp( scheme, "owncloud" ) == 0 ) {
+        strcpy( protocol, "http");
+    } else if( strcmp( scheme, "ownclouds" ) == 0 ) {
+        strcpy( protocol, "https");
+        useSSL = 1;
+    } else {
+        DEBUG_WEBDAV("Invalid scheme %s, go outa here!", scheme );
+        rc = -1;
+        goto out;
+    }
+
+    DEBUG_WEBDAV("* user %s", dav_session.user ? dav_session.user : "");
+
+    if (port == 0) {
+        port = ne_uri_defaultport(protocol);
+    }
+
+#if 0
+    rc = ne_sock_init();
+    DEBUG_WEBDAV("ne_sock_init: %d", rc );
+    if (rc < 0) {
+        rc = -1;
+        goto out;
+    }
+#endif
+
+    dav_session.ctx = ne_session_create( protocol, host, port);
+
+    if (dav_session.ctx == NULL) {
+        DEBUG_WEBDAV("Session create with protocol %s failed", protocol );
+        rc = -1;
+        goto out;
+    }
+
+    if (dav_session.read_timeout == 0)
+        dav_session.read_timeout = 300;  // set 300 seconds as default.
+
+    ne_set_read_timeout(dav_session.ctx, dav_session.read_timeout);
+
+    snprintf( uaBuf, sizeof(uaBuf), "Mozilla/5.0 (%s) csyncoC/%s",
+              get_platform(), CSYNC_STRINGIFY( LIBCSYNC_VERSION ));
+    ne_set_useragent( dav_session.ctx, uaBuf);
+    ne_set_server_auth(dav_session.ctx, ne_auth, 0 );
+
+    if( useSSL ) {
+        if (!ne_has_support(NE_FEATURE_SSL)) {
+            DEBUG_WEBDAV("Error: SSL is not enabled.");
+            rc = -1;
+            goto out;
+        }
+
+        ne_ssl_trust_default_ca( dav_session.ctx );
+        ne_ssl_set_verify( dav_session.ctx, verify_sslcert, 0 );
+    }
+
+    /* Hook called when a request is created. It sets the proxy connection header. */
+    ne_hook_create_request( dav_session.ctx, request_created_hook, NULL );
+    /* Hook called after response headers are read. It gets the Session ID. */
+    ne_hook_post_headers( dav_session.ctx, post_request_hook, NULL );
+    /* Hook called before a request is sent. It sets the cookies. */
+    ne_hook_pre_send( dav_session.ctx, pre_send_hook, NULL );
+    /* Hook called after request is dispatched. Used for handling possible redirections. */
+    ne_hook_post_send( dav_session.ctx, post_send_hook, NULL );
+
+    /* Proxy support */
+    proxystate = configureProxy( dav_session.ctx );
+    if( proxystate < 0 ) {
+        DEBUG_WEBDAV("Error: Proxy-Configuration failed.");
+    } else if( proxystate > 0 ) {
+        ne_set_proxy_auth( dav_session.ctx, ne_proxy_auth, 0 );
+    }
+
+    _connected = 1;
+    rc = 0;
+out:
+    SAFE_FREE(path);
+    SAFE_FREE(host);
+    SAFE_FREE(scheme);
+    return rc;
+}
+
+/*
+ * result parsing list.
+ * This function is called to parse the result of the propfind request
+ * to list directories on the WebDAV server. I takes a single resource
+ * and fills a resource struct and stores it to the result list which
+ * is stored in the listdir_context.
+ */
+static void results(void *userdata,
+                    const ne_uri *uri,
+                    const ne_prop_result_set *set)
+{
+    struct listdir_context *fetchCtx = userdata;
+    struct resource *newres = 0;
+    const char *clength, *modtime = NULL;
+    const char *resourcetype = NULL;
+    const char *md5sum = NULL;
+    const char *file_id = NULL;
+    const ne_status *status = NULL;
+    char *path = ne_path_unescape( uri->path );
+
+    (void) status;
+    if( ! fetchCtx ) {
+        DEBUG_WEBDAV("No valid fetchContext");
+        return;
+    }
+
+    if( ! fetchCtx->target ) {
+        DEBUG_WEBDAV("error: target must not be zero!" );
+        return;
+    }
+
+    /* Fill the resource structure with the data about the file */
+    newres = c_malloc(sizeof(struct resource));
+    newres->uri =  path; /* no need to strdup because ne_path_unescape already allocates */
+    newres->name = c_basename( path );
+
+    modtime      = ne_propset_value( set, &ls_props[0] );
+    clength      = ne_propset_value( set, &ls_props[1] );
+    resourcetype = ne_propset_value( set, &ls_props[2] );
+    md5sum       = ne_propset_value( set, &ls_props[3] );
+    file_id      = ne_propset_value( set, &ls_props[4] );
+
+    newres->type = resr_normal;
+    if( clength == NULL && resourcetype && strncmp( resourcetype, "<DAV:collection>", 16 ) == 0) {
+        newres->type = resr_collection;
+    }
+
+    if (modtime) {
+        newres->modtime = oc_httpdate_parse(modtime);
+    }
+
+    /* DEBUG_WEBDAV("Parsing Modtime: %s -> %llu", modtime, (unsigned long long) newres->modtime ); */
+    newres->size = 0;
+    if (clength) {
+        newres->size = atoll(clength);
+        /* DEBUG_WEBDAV("Parsed File size for %s from %s: %lld", newres->name, clength, (long long)newres->size ); */
+    }
+
+    if( md5sum ) {
+        int len = strlen(md5sum)-2;
+        if( len > 0 ) {
+            /* Skip the " around the string coming back from the ne_propset_value call */
+            newres->md5 = c_malloc(len+1);
+            strncpy( newres->md5, md5sum+1, len );
+            newres->md5[len] = '\0';
+        }
+    }
+
+    csync_vio_set_file_id(newres->file_id, file_id);
+
+    /* prepend the new resource to the result list */
+    newres->next   = fetchCtx->list;
+    fetchCtx->list = newres;
+    fetchCtx->result_count = fetchCtx->result_count + 1;
+    /* DEBUG_WEBDAV( "results for URI %s: %d %d", newres->name, (int)newres->size, (int)newres->type ); */
+}
+
+
+
+/*
+ * fetches a resource list from the WebDAV server. This is equivalent to list dir.
+ */
+static struct listdir_context *fetch_resource_list(const char *uri, int depth)
+{
+    struct listdir_context *fetchCtx;
+    int ret = 0;
+    ne_propfind_handler *hdl = NULL;
+    ne_request *request = NULL;
+    const char *content_type = NULL;
+    char *curi = NULL;
+    const ne_status *req_status = NULL;
+
+    curi = _cleanPath( uri );
+
+    /* The old legacy one-level PROPFIND cache. Also gets filled
+       by the recursive cache if 'infinity' did not suceed. */
+    if (propfind_cache) {
+        if (c_streq(curi, propfind_cache->target)) {
+            DEBUG_WEBDAV("fetch_resource_list Using simple PROPFIND cache %s", curi);
+            propfind_cache->ref++;
+            SAFE_FREE(curi);
+            return propfind_cache;
+        }
+    }
+
+    fetchCtx = c_malloc( sizeof( struct listdir_context ));
+    if (!fetchCtx) {
+        errno = ENOMEM;
+        SAFE_FREE(curi);
+        return NULL;
+    }
+    fetchCtx->list = NULL;
+    fetchCtx->target = curi;
+    fetchCtx->currResource = NULL;
+    fetchCtx->ref = 1;
+
+    /* do a propfind request and parse the results in the results function, set as callback */
+    hdl = ne_propfind_create(dav_session.ctx, curi, depth);
+
+    if(hdl) {
+        ret = ne_propfind_named(hdl, ls_props, results, fetchCtx);
+        request = ne_propfind_get_request( hdl );
+        req_status = ne_get_status( request );
+    }
+
+    if( ret == NE_OK ) {
+        fetchCtx->currResource = fetchCtx->list;
+        /* Check the request status. */
+        if( req_status && req_status->klass != 2 ) {
+            set_errno_from_http_errcode(req_status->code);
+            DEBUG_WEBDAV("ERROR: Request failed: status %d (%s)", req_status->code,
+                         req_status->reason_phrase);
+            ret = NE_CONNECT;
+            set_error_message(req_status->reason_phrase);
+            oc_notify_progress( uri, CSYNC_NOTIFY_ERROR,
+                                req_status->code,
+                                (intptr_t)(req_status->reason_phrase) );
+        }
+        DEBUG_WEBDAV("Simple propfind result code %d.", req_status->code);
+    } else {
+        if( ret == NE_ERROR && req_status->code == 404) {
+            errno = ENOENT;
+        } else {
+            set_errno_from_neon_errcode(ret);
+        }
+    }
+
+    if( ret == NE_OK ) {
+        /* Check the content type. If the server has a problem, ie. database is gone or such,
+         * the content type is not xml but a html error message. Stop on processing if it's
+         * not XML.
+         * FIXME: Generate user error message from the reply content.
+         */
+        content_type =  ne_get_response_header( request, "Content-Type" );
+        if( !(content_type && c_streq(content_type, "application/xml; charset=utf-8") ) ) {
+            DEBUG_WEBDAV("ERROR: Content type of propfind request not XML: %s.",
+                         content_type ?  content_type: "<empty>");
+            errno = ERRNO_WRONG_CONTENT;
+            set_error_message("Server error: PROPFIND reply is not XML formatted!");
+            ret = NE_CONNECT;
+        }
+    }
+
+    if( ret != NE_OK ) {
+        const char *err = NULL;
+
+        err = ne_get_error( dav_session.ctx );
+        DEBUG_WEBDAV("WRN: propfind named failed with %d, request error: %s", ret, err ? err : "<nil>");
+    }
+
+    if( hdl )
+        ne_propfind_destroy(hdl);
+
+    if( ret != NE_OK ) {
+        free_fetchCtx(fetchCtx);
+        return NULL;
+    }
+
+    free_fetchCtx(propfind_cache);
+    propfind_cache = fetchCtx;
+    propfind_cache->ref++;
+    return fetchCtx;
+}
+
+static struct listdir_context *fetch_resource_list_attempts(const char *uri, int depth)
+{
+    int i;
+
+    struct listdir_context *fetchCtx = NULL;
+    for(i = 0; i < 10; ++i) {
+        fetchCtx = fetch_resource_list(uri, depth);
+        if(fetchCtx) break;
+        /* only loop in case the content is not XML formatted. Otherwise for every
+         * non successful stat (for non existing directories) its tried 10 times. */
+        if( errno != ERRNO_WRONG_CONTENT ) break;
+
+        DEBUG_WEBDAV("=> Errno after fetch resource list for %s: %d", uri, errno);
+        DEBUG_WEBDAV("   New attempt %i", i);
+    }
+    return fetchCtx;
+}
+
+static void fill_stat_cache( csync_vio_file_stat_t *lfs ) {
+
+    if( _stat_cache.name ) SAFE_FREE(_stat_cache.name);
+    if( _stat_cache.etag  ) SAFE_FREE(_stat_cache.etag );
+
+    if( !lfs) return;
+
+    _stat_cache.name   = c_strdup(lfs->name);
+    _stat_cache.mtime  = lfs->mtime;
+    _stat_cache.fields = lfs->fields;
+    _stat_cache.type   = lfs->type;
+    _stat_cache.size   = lfs->size;
+    csync_vio_file_stat_set_file_id(&_stat_cache, lfs->file_id);
+
+    if( lfs->etag ) {
+        _stat_cache.etag    = c_strdup(lfs->etag);
+    }
+}
+
+
+
+/*
+ * file functions
+ */
+static int owncloud_stat(const char *uri, csync_vio_file_stat_t *buf) {
+    /* get props:
+     *   modtime
+     *   creattime
+     *   size
+     */
+    csync_vio_file_stat_t *lfs = NULL;
+    struct listdir_context  *fetchCtx = NULL;
+    char *decodedUri = NULL;
+    int len = 0;
+    errno = 0;
+
+    DEBUG_WEBDAV("owncloud_stat %s called", uri );
+
+    buf->name = c_basename(uri);
+
+    if (buf->name == NULL) {
+        errno = ENOMEM;
+        return -1;
+    }
+
+    if( _stat_cache.name && strcmp( buf->name, _stat_cache.name ) == 0 ) {
+        buf->fields  = CSYNC_VIO_FILE_STAT_FIELDS_NONE;
+        buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_TYPE;
+        buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_SIZE;
+        buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_MTIME;
+        buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_PERMISSIONS;
+        buf->fields  = _stat_cache.fields;
+        buf->type    = _stat_cache.type;
+        buf->mtime   = _stat_cache.mtime;
+        buf->size    = _stat_cache.size;
+        buf->mode    = _stat_perms( _stat_cache.type );
+        buf->etag     = NULL;
+        if( _stat_cache.etag ) {
+            buf->etag    = c_strdup( _stat_cache.etag );
+            buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_ETAG;
+        }
+        csync_vio_file_stat_set_file_id( buf, _stat_cache.file_id );
+        return 0;
+    }
+    DEBUG_WEBDAV("owncloud_stat => Could not find in stat cache %s", uri);
+
+    /* fetch data via a propfind call. */
+    /* fetchCtx = fetch_resource_list( uri, NE_DEPTH_ONE); */
+    fetchCtx = fetch_resource_list_attempts( uri, NE_DEPTH_ONE);
+    DEBUG_WEBDAV("=> Errno after fetch resource list for %s: %d", uri, errno);
+    if (!fetchCtx) {
+        return -1;
+    }
+
+    if( fetchCtx ) {
+        struct resource *res = fetchCtx->list;
+        while( res ) {
+            /* remove trailing slashes */
+            len = strlen(res->uri);
+            while( len > 0 && res->uri[len-1] == '/' ) --len;
+            decodedUri = ne_path_unescape( fetchCtx->target ); /* allocates memory */
+
+            /* Only do the comparaison of the part of the string without the trailing
+               slashes, and make sure decodedUri is not too large */
+            if( strncmp(res->uri, decodedUri, len ) == 0 && decodedUri[len] == '\0') {
+                SAFE_FREE( decodedUri );
+                break;
+            }
+            res = res->next;
+            SAFE_FREE( decodedUri );
+        }
+        if( res ) {
+            DEBUG_WEBDAV("Working on file %s", res->name );
+        } else {
+            DEBUG_WEBDAV("ERROR: Result struct not valid!");
+        }
+
+        lfs = resourceToFileStat( res );
+        if( lfs ) {
+            buf->fields = CSYNC_VIO_FILE_STAT_FIELDS_NONE;
+            buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_TYPE;
+            buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_SIZE;
+            buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_MTIME;
+            buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_PERMISSIONS;
+            buf->fields |= CSYNC_VIO_FILE_STAT_FIELDS_ETAG;
+
+            buf->fields = lfs->fields;
+            buf->type   = lfs->type;
+            buf->mtime  = lfs->mtime;
+            buf->size   = lfs->size;
+            buf->mode   = _stat_perms( lfs->type );
+            buf->etag    = NULL;
+            if( lfs->etag ) {
+                buf->etag    = c_strdup( lfs->etag );
+            }
+            csync_vio_file_stat_set_file_id( buf, lfs->file_id );
+
+            /* fill the static stat buf as input for the stat function */
+            csync_vio_file_stat_destroy( lfs );
+        }
+
+        free_fetchCtx( fetchCtx );
+    }
+    DEBUG_WEBDAV("STAT result from propfind: %s, mtime: %llu", buf->name ? buf->name:"NULL",
+                    (unsigned long long) buf->mtime );
+
+    return 0;
+}
+
+/* capabilities are currently:
+ *  bool atomar_copy_support - oC provides atomar copy
+ *  bool do_post_copy_stat   - oC does not want the post copy check
+ *  bool time_sync_required  - oC does not require the time sync
+ *  int  unix_extensions     - oC supports unix extensions.
+ *  bool propagate_on_fd     - oC supports the send_file method.
+ */
+static csync_vio_capabilities_t _owncloud_capabilities = { true, false, false, 0, true, false, false };
+
+static csync_vio_capabilities_t *owncloud_capabilities(void)
+{
+#ifdef _WIN32
+  _owncloud_capabilities.unix_extensions = 0;
+#endif
+  return &_owncloud_capabilities;
+}
+
+static const char* owncloud_get_etag( const char *path )
+{
+    ne_request *req    = NULL;
+    const char *header = NULL;
+    char *uri          = _cleanPath(path);
+    char *buf          = NULL;
+    const char *cbuf   = NULL;
+    csync_vio_file_stat_t *fs = NULL;
+    bool doHeadRequest = false;
+
+    if (_id_cache.uri && c_streq(path, _id_cache.uri)) {
+        header = _id_cache.id;
+    }
+
+    doHeadRequest= false; /* ownCloud server doesn't have good support for HEAD yet */
+
+    if( !header && doHeadRequest ) {
+        int neon_stat;
+        /* Perform an HEAD request to the resource. HEAD delivers the
+         * ETag header back. */
+        req = ne_request_create(dav_session.ctx, "HEAD", uri);
+        neon_stat = ne_request_dispatch(req);
+        set_errno_from_neon_errcode( neon_stat );
+
+        header = ne_get_response_header(req, "etag");
+    }
+    /* If the request went wrong or the server did not respond correctly
+     * (that can happen for collections) a stat call is done which translates
+     * into a PROPFIND request.
+     */
+    if( ! header ) {
+        /* ... and do a stat call. */
+        fs = csync_vio_file_stat_new();
+        if(fs == NULL) {
+            DEBUG_WEBDAV( "owncloud_get_etag: memory fault.");
+            errno = ENOMEM;
+            return NULL;
+        }
+        if( owncloud_stat( path, fs ) == 0 ) {
+            header = fs->etag;
+        }
+    }
+
+    /* In case the result is surrounded by "" cut them away. */
+    if( header ) {
+        if( header [0] == '"' && header[ strlen(header)-1] == '"') {
+            int len = strlen( header )-2;
+            buf = c_malloc( len+1 );
+            strncpy( buf, header+1, len );
+            buf[len] = '\0';
+            cbuf = buf;
+            /* do not free header here, as it belongs to the request */
+        } else {
+            cbuf = c_strdup(header);
+        }
+    }
+
+    /* fix server problem: If we end up with an empty string, set something strange... */
+    if( c_streq(cbuf, "") || c_streq(cbuf, "\"\"") ) {
+        SAFE_FREE(cbuf);
+        cbuf = c_strdup("empty_etag");
+    }
+
+    DEBUG_WEBDAV("Get file ID for %s: %s", path, cbuf ? cbuf:"<null>");
+    if( fs ) csync_vio_file_stat_destroy(fs);
+    if( req ) ne_request_destroy(req);
+    SAFE_FREE(uri);
+
+    return cbuf;
+}
+
+/*
+ * directory functions
+ */
+static csync_vio_method_handle_t *owncloud_opendir(const char *uri) {
+    struct listdir_context *fetchCtx = NULL;
+    char *curi = NULL;
+
+    DEBUG_WEBDAV("opendir method called on %s", uri );
+
+    dav_connect( uri );
+
+    curi = _cleanPath( uri );
+    if (is_first_propfind && !dav_session.no_recursive_propfind) {
+        is_first_propfind = false;
+        // Try to fill it
+        fill_recursive_propfind_cache(uri, curi);
+    }
+    if (propfind_recursive_cache) {
+        // Try to fetch from recursive cache (if we have one)
+        fetchCtx = get_listdir_context_from_recursive_cache(curi);
+    }
+    SAFE_FREE(curi);
+    is_first_propfind = false;
+    if (fetchCtx) {
+        return fetchCtx;
+    }
+
+    /* fetchCtx = fetch_resource_list( uri, NE_DEPTH_ONE ); */
+    fetchCtx = fetch_resource_list_attempts( uri, NE_DEPTH_ONE);
+    if( !fetchCtx ) {
+        /* errno is set properly in fetch_resource_list */
+        DEBUG_WEBDAV("Errno set to %d", errno);
+        return NULL;
+    } else {
+        fetchCtx->currResource = fetchCtx->list;
+        DEBUG_WEBDAV("opendir returning handle %p (count=%d)", (void*) fetchCtx, fetchCtx->result_count );
+        return fetchCtx;
+    }
+    /* no freeing of curi because its part of the fetchCtx and gets freed later */
+}
+
+static int owncloud_closedir(csync_vio_method_handle_t *dhandle) {
+
+    struct listdir_context *fetchCtx = dhandle;
+
+    DEBUG_WEBDAV("closedir method called %p!", dhandle);
+
+    free_fetchCtx(fetchCtx);
+
+    return 0;
+}
+
+static csync_vio_file_stat_t *owncloud_readdir(csync_vio_method_handle_t *dhandle) {
+
+    struct listdir_context *fetchCtx = dhandle;
+
+    if( fetchCtx == NULL) {
+        /* DEBUG_WEBDAV("An empty dir or at end"); */
+        return NULL;
+    }
+
+    while( fetchCtx->currResource ) {
+        resource* currResource = fetchCtx->currResource;
+        char *escaped_path = NULL;
+
+        /* set pointer to next element */
+        fetchCtx->currResource = fetchCtx->currResource->next;
+
+        /* It seems strange: first uri->path is unescaped to escape it in the next step again.
+         * The reason is that uri->path is not completely escaped (ie. it seems only to have
+         * spaces escaped), while the fetchCtx->target is fully escaped.
+         * See http://bugs.owncloud.org/thebuggenie/owncloud/issues/oc-613
+         */
+        escaped_path = ne_path_escape( currResource->uri );
+        if (ne_path_compare(fetchCtx->target, escaped_path) != 0) {
+            csync_vio_file_stat_t* lfs = resourceToFileStat(currResource);
+            fill_stat_cache(lfs);
+            SAFE_FREE( escaped_path );
+            return lfs;
+        }
+
+        /* This is the target URI */
+        SAFE_FREE( escaped_path );
+    }
+
+    return NULL;
+}
+
+static char *owncloud_error_string()
+{
+    return dav_session.error_string;
+}
+
+static int owncloud_commit() {
+
+  clean_caches();
+
+  if( dav_session.ctx )
+    ne_session_destroy( dav_session.ctx );
+  /* DEBUG_WEBDAV( "********** vio_module_shutdown" ); */
+
+  dav_session.ctx = 0;
+
+  // ne_sock_exit();
+  _connected = 0;  /* triggers dav_connect to go through the whole neon setup */
+
+  SAFE_FREE( dav_session.user );
+  SAFE_FREE( dav_session.pwd );
+  SAFE_FREE( dav_session.session_key);
+  SAFE_FREE( dav_session.error_string );
+
+  SAFE_FREE( dav_session.proxy_type );
+  SAFE_FREE( dav_session.proxy_host );
+  SAFE_FREE( dav_session.proxy_user );
+  SAFE_FREE( dav_session.proxy_pwd  );
+
+  return 0;
+}
+
+static int owncloud_set_property(const char *key, void *data) {
+#define READ_STRING_PROPERTY(P) \
+    if (c_streq(key, #P)) { \
+        SAFE_FREE(dav_session.P); \
+        dav_session.P = c_strdup((const char*)data); \
+        return 0; \
+    }
+    READ_STRING_PROPERTY(session_key)
+    READ_STRING_PROPERTY(proxy_type)
+    READ_STRING_PROPERTY(proxy_host)
+    READ_STRING_PROPERTY(proxy_user)
+    READ_STRING_PROPERTY(proxy_pwd)
+#undef READ_STRING_PROPERTY
+
+    if (c_streq(key, "proxy_port")) {
+        dav_session.proxy_port = *(int*)(data);
+        return 0;
+    }
+    if (c_streq(key, "read_timeout") || c_streq(key, "timeout")) {
+        dav_session.read_timeout = *(int*)(data);
+        return 0;
+    }
+    if( c_streq(key, "csync_context")) {
+        dav_session.csync_ctx = data;
+        return 0;
+    }
+    if( c_streq(key, "hbf_info")) {
+        dav_session.chunk_info = (csync_hbf_info_t *)(data);
+        return 0;
+    }
+    if( c_streq(key, "get_dav_session")) {
+        /* Give the ne_session to the caller */
+        *(ne_session**)data = dav_session.ctx;
+        return 0;
+    }
+    if( c_streq(key, "no_recursive_propfind")) {
+        dav_session.no_recursive_propfind = *(bool*)(data);
+        return 0;
+    }
+    if( c_streq(key, "hbf_block_size")) {
+        dav_session.hbf_block_size = *(int64_t*)(data);
+        return 0;
+    }
+    if( c_streq(key, "hbf_threshold")) {
+        dav_session.hbf_threshold = *(int64_t*)(data);
+        return 0;
+    }
+    if( c_streq(key, "bandwidth_limit_upload")) {
+        dav_session.bandwidth_limit_upload = *(int*)(data);
+        return 0;
+    }
+    if( c_streq(key, "bandwidth_limit_download")) {
+        dav_session.bandwidth_limit_download = *(int*)(data);
+        return 0;
+    }
+    if( c_streq(key, "overall_progress_data")) {
+      dav_session.overall_progress_data = (csync_overall_progress_t*)(data);
+    }
+    if( c_streq(key, "redirect_callback")) {
+        if (data) {
+            csync_owncloud_redirect_callback_t* cb_wrapper = data;
+
+            dav_session.redir_callback = *cb_wrapper;
+        } else {
+            dav_session.redir_callback = NULL;
+        }
+    }
+
+    return -1;
+}
+
+csync_vio_method_t _method = {
+    .method_table_size = sizeof(csync_vio_method_t),
+    .get_capabilities = owncloud_capabilities,
+    .get_etag = owncloud_get_etag,
+    .open = 0,
+    .creat = 0,
+    .close = 0,
+    .read = 0,
+    .write = 0,
+    .sendfile = 0,
+    .lseek = 0,
+    .opendir = owncloud_opendir,
+    .closedir = owncloud_closedir,
+    .readdir = owncloud_readdir,
+    .mkdir = 0,
+    .rmdir = 0,
+    .stat = owncloud_stat,
+    .rename = 0,
+    .unlink = 0,
+    .chmod = 0,
+    .chown = 0,
+    .utimes = 0,
+    .set_property = owncloud_set_property,
+    .get_error_string = owncloud_error_string,
+    .commit = owncloud_commit
+
+};
+
+csync_vio_method_t *vio_module_init(const char *method_name, const char *args,
+                                    csync_auth_callback cb, void *userdata) {
+    (void) method_name;
+    (void) args;
+    (void) userdata;
+
+    _authcb = cb;
+    _connected = 0;  /* triggers dav_connect to go through the whole neon setup */
+
+    memset(&dav_session, 0, sizeof(dav_session));
+
+    /* Disable it, Mirall can enable it for the first sync (= no DB)*/
+    dav_session.no_recursive_propfind = true;
+
+    return &_method;
+}
+
+void vio_module_shutdown(csync_vio_method_t *method) {
+    (void) method;
+
+    /* DEBUG_WEBDAV( "********** vio_module_shutdown" ); */
+}
+
+/* vim: set ts=4 sw=4 et cindent: */
diff --git a/src/csync_owncloud.h b/src/csync_owncloud.h
new file mode 100644
index 0000000..244e1b6
--- /dev/null
+++ b/src/csync_owncloud.h
@@ -0,0 +1,181 @@
+/*
+ * libcsync -- a library to sync a directory with another
+ *
+ * Copyright (c) 2011      by Andreas Schneider <asn@cryptomilk.org>
+ * Copyright (c) 2012      by Klaas Freitag <freitag@owncloud.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#ifndef CSYNC_OWNCLOUD_H
+#define CSYNC_OWNCLOUD_H
+
+#include <errno.h>
+#include <stdio.h>
+#include <time.h>
+#include <limits.h>
+#include <stdlib.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include "config.h"
+#ifdef NEON_WITH_LFS /* Switch on LFS in libneon. Never remove the NE_LFS! */
+#define NE_LFS
+#endif
+
+#include <neon/ne_basic.h>
+#include <neon/ne_socket.h>
+#include <neon/ne_session.h>
+#include <neon/ne_request.h>
+#include <neon/ne_props.h>
+#include <neon/ne_auth.h>
+#include <neon/ne_dates.h>
+#include <neon/ne_compress.h>
+#include <neon/ne_redirect.h>
+
+
+#include "c_rbtree.h"
+
+#include "c_lib.h"
+#include "csync.h"
+#include "csync_misc.h"
+#include "csync_macros.h"
+#include "c_private.h"
+#include "httpbf.h"
+
+#include "vio/csync_vio_module.h"
+#include "vio/csync_vio_file_stat.h"
+#include "vio/csync_vio.h"
+
+#include "csync_log.h"
+
+
+#define DEBUG_WEBDAV(...) csync_log( 9, "oc_module", __VA_ARGS__);
+
+enum resource_type {
+    resr_normal = 0,
+    resr_collection,
+    resr_reference,
+    resr_error
+};
+
+/* Struct to store data for each resource found during an opendir operation.
+ * It represents a single file entry.
+ */
+
+typedef struct resource {
+    char *uri;           /* The complete uri */
+    char *name;          /* The filename only */
+
+    enum resource_type type;
+    int64_t              size;
+    time_t             modtime;
+    char*              md5;
+    char               file_id[FILE_ID_BUF_SIZE+1];
+
+    struct resource    *next;
+} resource;
+
+/* Struct to hold the context of a WebDAV PropFind operation to fetch
+ * a directory listing from the server.
+ */
+struct listdir_context {
+    struct resource *list;           /* The list of result resources */
+    struct resource *currResource;   /* A pointer to the current resource */
+    char            *target;        /* Request-URI of the PROPFIND */
+    unsigned int     result_count;   /* number of elements stored in list */
+    int ref; /* reference count, only destroy when it reaches 0 */
+};
+
+
+/* Our cache, key is a char* */
+extern c_rbtree_t *propfind_recursive_cache;
+/* Values are propfind_recursive_element: */
+struct propfind_recursive_element {
+    struct resource *self;
+    struct resource *children;
+    struct propfind_recursive_element *parent;
+};
+typedef struct propfind_recursive_element propfind_recursive_element_t;
+void clear_propfind_recursive_cache(void);
+struct listdir_context *get_listdir_context_from_recursive_cache(const char *curi);
+void fill_recursive_propfind_cache(const char *uri, const char *curi);
+struct listdir_context *get_listdir_context_from_cache(const char *curi);
+void fetch_resource_list_recursive(const char *uri, const char *curi);
+
+typedef int (*csync_owncloud_redirect_callback_t)(CSYNC* ctx, const char* uri);
+
+/* Struct with the WebDAV session */
+struct dav_session_s {
+    ne_session *ctx;
+    char *user;
+    char *pwd;
+
+    char *proxy_type;
+    char *proxy_host;
+    int   proxy_port;
+    char *proxy_user;
+    char *proxy_pwd;
+
+    char *session_key;
+
+    char *error_string;
+
+    int read_timeout;
+
+    CSYNC *csync_ctx;
+
+    csync_hbf_info_t *chunk_info;
+
+    bool no_recursive_propfind;
+    int64_t hbf_block_size;
+    int64_t hbf_threshold;
+
+    /* If 0, it is disabled.   If >0,  in Byte/seconds. If < 0,  in % of the available bandwidth*/
+    int bandwidth_limit_upload;
+    int bandwidth_limit_download;
+
+    csync_overall_progress_t *overall_progress_data;
+    csync_owncloud_redirect_callback_t redir_callback;
+};
+extern struct dav_session_s dav_session;
+
+/* The list of properties that is fetched in PropFind on a collection */
+static const ne_propname ls_props[] = {
+    { "DAV:", "getlastmodified" },
+    { "DAV:", "getcontentlength" },
+    { "DAV:", "resourcetype" },
+    { "DAV:", "getetag"},
+    { "http://owncloud.org/ns", "id"},
+    { NULL, NULL }
+};
+
+void set_errno_from_http_errcode( int err );
+void set_error_message( const char *msg );
+void set_errno_from_neon_errcode( int neon_code );
+int http_result_code_from_session(void);
+void set_errno_from_session(void);
+
+time_t oc_httpdate_parse( const char *date );
+
+char *_cleanPath( const char* uri );
+
+int _stat_perms( int type );
+csync_vio_file_stat_t *resourceToFileStat( struct resource *res );
+
+void oc_notify_progress(const char *file, enum csync_notify_type_e kind, int64_t current_size, int64_t full_size);
+
+#endif /* CSYNC_OWNCLOUD_H */
diff --git a/src/csync_owncloud_recursive_propfind.c b/src/csync_owncloud_recursive_propfind.c
new file mode 100644
index 0000000..9f1aa90
--- /dev/null
+++ b/src/csync_owncloud_recursive_propfind.c
@@ -0,0 +1,338 @@
+/*
+ * libcsync -- a library to sync a directory with another
+ *
+ * Copyright (c) 2011      by Andreas Schneider <asn@cryptomilk.org>
+ * Copyright (c) 2012      by Klaas Freitag <freitag@owncloud.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "csync_owncloud.h"
+
+c_rbtree_t *propfind_recursive_cache = NULL;
+int propfind_recursive_cache_depth = 0;
+int propfind_recursive_cache_file_count = 0;
+int propfind_recursive_cache_folder_count = 0;
+
+
+static struct resource* resource_dup(struct resource* o) {
+    struct resource *r = c_malloc (sizeof( struct resource ));
+    r->uri = c_strdup(o->uri);
+    r->name = c_strdup(o->name);
+    r->type = o->type;
+    r->size = o->size;
+    r->modtime = o->modtime;
+    r->md5 = c_strdup(o->md5);
+    r->next = o->next;
+    csync_vio_set_file_id(r->file_id, o->file_id);
+
+    return r;
+}
+static void resource_free(struct resource* o) {
+    struct resource* old = NULL;
+    while (o)
+    {
+        old = o;
+        o = o->next;
+        SAFE_FREE(old->uri);
+        SAFE_FREE(old->name);
+        SAFE_FREE(old->md5);
+        SAFE_FREE(old);
+    }
+}
+
+static void _tree_destructor(void *data) {
+    propfind_recursive_element_t *element = data;
+    resource_free(element->self);
+    resource_free(element->children);
+    SAFE_FREE(element);
+}
+
+void clear_propfind_recursive_cache(void)
+{
+    if (propfind_recursive_cache) {
+        DEBUG_WEBDAV("clear_propfind_recursive_cache Invalidating..");
+        c_rbtree_destroy(propfind_recursive_cache, _tree_destructor);
+        propfind_recursive_cache = NULL;
+    }
+}
+
+struct listdir_context *get_listdir_context_from_recursive_cache(const char *curi)
+{
+    propfind_recursive_element_t *element = NULL;
+    struct listdir_context *fetchCtx = NULL;
+    struct resource *iterator, *r;
+
+    if (!propfind_recursive_cache) {
+        DEBUG_WEBDAV("get_listdir_context_from_recursive_cache No cache");
+        return NULL;
+    }
+
+    element = c_rbtree_node_data(c_rbtree_find(propfind_recursive_cache, curi));
+    if (!element) {
+        DEBUG_WEBDAV("get_listdir_context_from_recursive_cache No element %s in cache found", curi);
+        return NULL;
+    }
+
+    /* Out of the element, create a listdir_context.. if we could be sure that it is immutable, we could ref instead.. need to investigate */
+    fetchCtx = c_malloc( sizeof( struct listdir_context ));
+    fetchCtx->list = NULL;
+    fetchCtx->target = c_strdup(curi);
+    fetchCtx->currResource = NULL;
+    fetchCtx->ref = 1;
+
+    iterator = element->children;
+    r = NULL;
+    while (iterator) {
+        r = resource_dup(iterator);
+        r->next = fetchCtx->list;
+        fetchCtx->list = r;
+        iterator = iterator->next;
+        fetchCtx->result_count++;
+        /* DEBUG_WEBDAV("get_listdir_context_from_cache Returning cache for %s element %s", fetchCtx->target, fetchCtx->list->uri); */
+    }
+
+    r = resource_dup(element->self);
+    r->next = fetchCtx->list;
+    fetchCtx->result_count++;
+    fetchCtx->list = r;
+    fetchCtx->currResource = fetchCtx->list;
+    DEBUG_WEBDAV("get_listdir_context_from_cache Returning cache for %s (%d elements)", fetchCtx->target, fetchCtx->result_count);
+    return fetchCtx;
+}
+
+static int _key_cmp(const void *key, const void *b) {
+    const char *elementAUri = (char*)key;
+    const propfind_recursive_element_t *elementB = b;
+    return ne_path_compare(elementAUri, elementB->self->uri);
+}
+static int _data_cmp(const void *a, const void *b) {
+    const propfind_recursive_element_t *elementA = a;
+    const propfind_recursive_element_t *elementB = b;
+    return ne_path_compare(elementA->self->uri, elementB->self->uri);
+}
+static void propfind_results_recursive(void *userdata,
+                    const ne_uri *uri,
+                    const ne_prop_result_set *set)
+{
+    struct resource *newres = 0;
+    const char *clength, *modtime, *file_id = NULL;
+    const char *resourcetype = NULL;
+    const char *md5sum = NULL;
+    const ne_status *status = NULL;
+    char *path = ne_path_unescape( uri->path );
+    char *parentPath;
+    char *propfindRootUri = (char*) userdata;
+    propfind_recursive_element_t *element = NULL;
+    propfind_recursive_element_t *pElement = NULL;
+    int depth = 0;
+
+    (void) status;
+    (void) propfindRootUri;
+
+    if (!propfind_recursive_cache) {
+        c_rbtree_create(&propfind_recursive_cache, _key_cmp, _data_cmp);
+    }
+
+    /* Fill the resource structure with the data about the file */
+    newres = c_malloc(sizeof(struct resource));
+    newres->uri =  path; /* no need to strdup because ne_path_unescape already allocates */
+    newres->name = c_basename( path );
+
+    modtime      = ne_propset_value( set, &ls_props[0] );
+    clength      = ne_propset_value( set, &ls_props[1] );
+    resourcetype = ne_propset_value( set, &ls_props[2] );
+    md5sum       = ne_propset_value( set, &ls_props[3] );
+    file_id      = ne_propset_value( set, &ls_props[4] );
+
+    newres->type = resr_normal;
+    if( resourcetype && strncmp( resourcetype, "<DAV:collection>", 16 ) == 0) {
+        newres->type = resr_collection;
+        propfind_recursive_cache_folder_count++;
+    } else {
+        /* DEBUG_WEBDAV("propfind_results_recursive %s [%d]", newres->uri, newres->type); */
+        propfind_recursive_cache_file_count++;
+    }
+
+    if (modtime) {
+        newres->modtime = oc_httpdate_parse(modtime);
+    }
+
+    /* DEBUG_WEBDAV("Parsing Modtime: %s -> %llu", modtime, (unsigned long long) newres->modtime ); */
+    newres->size = 0;
+    if (clength) {
+        newres->size = atoll(clength);
+        /* DEBUG_WEBDAV("Parsed File size for %s from %s: %lld", newres->name, clength, (long long)newres->size ); */
+    }
+
+    if( md5sum ) {
+        int len = strlen(md5sum)-2;
+        if( len > 0 ) {
+            /* Skip the " around the string coming back from the ne_propset_value call */
+            newres->md5 = c_malloc(len+1);
+            strncpy( newres->md5, md5sum+1, len );
+            newres->md5[len] = '\0';
+        }
+    }
+
+    csync_vio_set_file_id(newres->file_id, file_id);
+    /*
+    DEBUG_WEBDAV("propfind_results_recursive %s [%s] %s", newres->uri, newres->type == resr_collection ? "collection" : "file", newres->md5);
+    */
+
+    /* Create new item in rb tree */
+    if (newres->type == resr_collection) {
+        DEBUG_WEBDAV("propfind_results_recursive %s is a folder", newres->uri);
+        /* Check if in rb tree */
+        element = c_rbtree_node_data(c_rbtree_find(propfind_recursive_cache,uri->path));
+        /* If not, create a new item and insert it */
+        if (!element) {
+            element = c_malloc(sizeof(propfind_recursive_element_t));
+            element->self = resource_dup(newres);
+            element->children = NULL;
+            element->parent = NULL;
+            c_rbtree_insert(propfind_recursive_cache, element);
+            /* DEBUG_WEBDAV("results_recursive Added collection %s", newres->uri); */
+        }
+    }
+
+    /* Check for parent in tree. If exists: Insert it into the children elements there */
+    parentPath = ne_path_parent(uri->path);
+    if (parentPath) {
+        propfind_recursive_element_t *parentElement = NULL;
+
+        parentElement = c_rbtree_node_data(c_rbtree_find(propfind_recursive_cache,parentPath));
+        free(parentPath);
+
+        if (parentElement) {
+            newres->next = parentElement->children;
+            parentElement->children = newres;
+
+            /* If the current result is a collection we also need to set its parent */
+            if (element)
+                element->parent = parentElement;
+
+            pElement = element;
+            while (pElement) {
+                depth++;
+                pElement = pElement->parent;
+            }
+            if (depth > propfind_recursive_cache_depth) {
+                DEBUG_WEBDAV("propfind_results_recursive %s new maximum tree depth %d", newres->uri, depth);
+                propfind_recursive_cache_depth = depth;
+            }
+
+            /* DEBUG_WEBDAV("results_recursive Added child %s to collection %s", newres->uri, element->self->uri); */
+        } else {
+            /* DEBUG_WEBDAV("results_recursive No parent %s found for child %s", parentPath, newres->uri); */
+            resource_free(newres);
+            newres = NULL;
+        }
+    }
+
+}
+
+void fetch_resource_list_recursive(const char *uri, const char *curi)
+{
+    int ret = 0;
+    ne_propfind_handler *hdl = NULL;
+    ne_request *request = NULL;
+    const char *content_type = NULL;
+    const ne_status *req_status = NULL;
+    int depth = NE_DEPTH_INFINITE;
+
+    DEBUG_WEBDAV("fetch_resource_list_recursive Starting recursive propfind %s %s", uri, curi);
+
+    /* do a propfind request and parse the results in the results function, set as callback */
+    hdl = ne_propfind_create(dav_session.ctx, curi, depth);
+
+    if(hdl) {
+        ret = ne_propfind_named(hdl, ls_props, propfind_results_recursive, (void*)curi);
+        request = ne_propfind_get_request( hdl );
+        req_status = ne_get_status( request );
+    }
+
+    if( ret == NE_OK ) {
+        /* Check the request status. */
+        if( req_status && req_status->klass != 2 ) {
+            set_errno_from_http_errcode(req_status->code);
+            DEBUG_WEBDAV("ERROR: Request failed: status %d (%s)", req_status->code,
+                         req_status->reason_phrase);
+            ret = NE_CONNECT;
+            set_error_message(req_status->reason_phrase);
+            oc_notify_progress(uri, CSYNC_NOTIFY_ERROR,  req_status->code, (intptr_t)(req_status->reason_phrase));
+        }
+        DEBUG_WEBDAV("Recursive propfind result code %d.", req_status ? req_status->code : 0);
+    } else {
+        if( ret == NE_ERROR && req_status->code == 404) {
+            errno = ENOENT;
+        } else {
+            set_errno_from_neon_errcode(ret);
+        }
+    }
+
+    if( ret == NE_OK ) {
+        /* Check the content type. If the server has a problem, ie. database is gone or such,
+         * the content type is not xml but a html error message. Stop on processing if it's
+         * not XML.
+         * FIXME: Generate user error message from the reply content.
+         */
+        content_type =  ne_get_response_header( request, "Content-Type" );
+        if( !(content_type && c_streq(content_type, "application/xml; charset=utf-8") ) ) {
+            DEBUG_WEBDAV("ERROR: Content type of propfind request not XML: %s.",
+                         content_type ?  content_type: "<empty>");
+            errno = ERRNO_WRONG_CONTENT;
+            set_error_message("Server error: PROPFIND reply is not XML formatted!");
+            ret = NE_CONNECT;
+        }
+    }
+
+    if( ret != NE_OK ) {
+        const char *err = NULL;
+
+        err = ne_get_error( dav_session.ctx );
+        DEBUG_WEBDAV("WRN: propfind named failed with %d, request error: %s", ret, err ? err : "<nil>");
+    }
+
+    if( hdl )
+        ne_propfind_destroy(hdl);
+
+    if( ret != NE_OK ) {
+        return;
+    }
+
+    return;
+}
+
+/* Called by owncloud_opendir()->fetch_resource_list() to fill the cache */
+extern struct listdir_context *propfind_cache;
+void fill_recursive_propfind_cache(const char *uri, const char *curi) {
+    fetch_resource_list_recursive(uri, curi);
+
+    if (propfind_recursive_cache_depth <= 2) {
+        DEBUG_WEBDAV("fill_recursive_propfind_cache %s Server maybe did not give us an 'infinity' depth result", curi);
+        /* transform the cache to the normal cache in propfind_cache */
+        propfind_cache = get_listdir_context_from_recursive_cache(curi);
+        /* clear the cache, it is bogus since the server returned only results for Depth 1 */
+        clear_propfind_recursive_cache();
+    } else {
+        DEBUG_WEBDAV("fill_recursive_propfind_cache %s We received %d elements deep for 'infinity' depth (%d folders, %d files)",
+                     curi,
+                     propfind_recursive_cache_depth,
+                     propfind_recursive_cache_folder_count,
+                     propfind_recursive_cache_file_count);
+
+    }
+}
diff --git a/src/csync_owncloud_util.c b/src/csync_owncloud_util.c
new file mode 100644
index 0000000..4d99055
--- /dev/null
+++ b/src/csync_owncloud_util.c
@@ -0,0 +1,364 @@
+/*
+ * libcsync -- a library to sync a directory with another
+ *
+ * Copyright (c) 2011      by Andreas Schneider <asn@cryptomilk.org>
+ * Copyright (c) 2012      by Klaas Freitag <freitag@owncloud.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "csync_owncloud.h"
+#include "csync_misc.h"
+
+void set_error_message( const char *msg )
+{
+    SAFE_FREE(dav_session.error_string);
+    if( msg )
+        dav_session.error_string = c_strdup(msg);
+}
+
+void set_errno_from_http_errcode( int err ) {
+    int new_errno = 0;
+
+    switch(err) {
+    case 200:           /* OK */
+    case 201:           /* Created */
+    case 202:           /* Accepted */
+    case 203:           /* Non-Authoritative Information */
+    case 204:           /* No Content */
+    case 205:           /* Reset Content */
+    case 207:           /* Multi-Status */
+    case 304:           /* Not Modified */
+        new_errno = 0;
+        break;
+    case 401:           /* Unauthorized */
+    case 402:           /* Payment Required */
+    case 407:           /* Proxy Authentication Required */
+    case 405:
+        new_errno = EPERM;
+        break;
+    case 301:           /* Moved Permanently */
+    case 303:           /* See Other */
+    case 404:           /* Not Found */
+    case 410:           /* Gone */
+        new_errno = ENOENT;
+        break;
+    case 408:           /* Request Timeout */
+    case 504:           /* Gateway Timeout */
+        new_errno = EAGAIN;
+        break;
+    case 423:           /* Locked */
+        new_errno = EACCES;
+        break;
+    case 400:           /* Bad Request */
+    case 403:           /* Forbidden */
+    case 409:           /* Conflict */
+    case 411:           /* Length Required */
+    case 412:           /* Precondition Failed */
+    case 414:           /* Request-URI Too Long */
+    case 415:           /* Unsupported Media Type */
+    case 424:           /* Failed Dependency */
+    case 501:           /* Not Implemented */
+        new_errno = EINVAL;
+        break;
+    case 507:           /* Insufficient Storage */
+        new_errno = ENOSPC;
+        break;
+    case 206:           /* Partial Content */
+    case 300:           /* Multiple Choices */
+    case 302:           /* Found */
+    case 305:           /* Use Proxy */
+    case 306:           /* (Unused) */
+    case 307:           /* Temporary Redirect */
+    case 406:           /* Not Acceptable */
+    case 416:           /* Requested Range Not Satisfiable */
+    case 417:           /* Expectation Failed */
+    case 422:           /* Unprocessable Entity */
+    case 500:           /* Internal Server Error */
+    case 502:           /* Bad Gateway */
+    case 505:           /* HTTP Version Not Supported */
+        new_errno = EIO;
+        break;
+    case 503:           /* Service Unavailable */
+        new_errno = ERRNO_SERVICE_UNAVAILABLE;
+        break;
+    case 413:           /* Request Entity too Large */
+        new_errno = EFBIG;
+        break;
+    default:
+        new_errno = EIO;
+    }
+
+    errno = new_errno;
+}
+
+int http_result_code_from_session() {
+    const char *p = ne_get_error( dav_session.ctx );
+    char *q;
+    int err;
+
+    set_error_message(p); /* remember the error message */
+
+    err = strtol(p, &q, 10);
+    if (p == q) {
+        err = ERRNO_ERROR_STRING;
+    }
+    return err;
+}
+
+void set_errno_from_session() {
+    int err = http_result_code_from_session();
+
+    if( err == EIO || err == ERRNO_ERROR_STRING) {
+        errno = err;
+    } else {
+        set_errno_from_http_errcode(err);
+    }
+}
+
+void set_errno_from_neon_errcode( int neon_code ) {
+
+    if( neon_code != NE_OK ) {
+        DEBUG_WEBDAV("Neon error code was %d", neon_code);
+    }
+
+    switch(neon_code) {
+    case NE_OK:     /* Success, but still the possiblity of problems */
+    case NE_ERROR:  /* Generic error; use ne_get_error(session) for message */
+        set_errno_from_session(); /* Something wrong with http communication */
+        break;
+    case NE_LOOKUP:  /* Server or proxy hostname lookup failed */
+        errno = ERRNO_LOOKUP_ERROR;
+        break;
+    case NE_AUTH:     /* User authentication failed on server */
+        errno = ERRNO_USER_UNKNOWN_ON_SERVER;
+        break;
+    case NE_PROXYAUTH:  /* User authentication failed on proxy */
+        errno = ERRNO_PROXY_AUTH;
+        break;
+    case NE_CONNECT:  /* Could not connect to server */
+        errno = ERRNO_CONNECT;
+        break;
+    case NE_TIMEOUT:  /* Connection timed out */
+        errno = ERRNO_TIMEOUT;
+        break;
+    case NE_FAILED:   /* The precondition failed */
+        errno = ERRNO_PRECONDITION;
+        break;
+    case NE_RETRY:    /* Retry request (ne_end_request ONLY) */
+        errno = ERRNO_RETRY;
+        break;
+
+    case NE_REDIRECT: /* See ne_redirect.h */
+        errno = ERRNO_REDIRECT;
+        break;
+    default:
+        errno = ERRNO_GENERAL_ERROR;
+    }
+}
+
+/* cleanPath to return an escaped path of an uri */
+char *_cleanPath( const char* uri ) {
+    int rc = 0;
+    char *path = NULL;
+    char *re = NULL;
+
+    rc = c_parse_uri( uri, NULL, NULL, NULL, NULL, NULL, &path );
+    if( rc  < 0 ) {
+        DEBUG_WEBDAV("Unable to cleanPath %s", uri ? uri: "<zero>" );
+        re = NULL;
+    } else {
+        re = ne_path_escape( path );
+    }
+
+    SAFE_FREE( path );
+    return re;
+}
+
+
+#ifndef HAVE_TIMEGM
+#ifdef _WIN32
+static int is_leap(unsigned y) {
+    y += 1900;
+    return (y % 4) == 0 && ((y % 100) != 0 || (y % 400) == 0);
+}
+
+static time_t timegm(struct tm *tm) {
+    static const unsigned ndays[2][12] = {
+    {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
+    {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} };
+
+    time_t res = 0;
+    int i;
+
+    for (i = 70; i < tm->tm_year; ++i)
+        res += is_leap(i) ? 366 : 365;
+
+    for (i = 0; i < tm->tm_mon; ++i)
+        res += ndays[is_leap(tm->tm_year)][i];
+     res += tm->tm_mday - 1;
+     res *= 24;
+     res += tm->tm_hour;
+     res *= 60;
+     res += tm->tm_min;
+     res *= 60;
+     res += tm->tm_sec;
+     return res;
+}
+#else
+/* A hopefully portable version of timegm */
+static time_t timegm(struct tm *tm ) {
+     time_t ret;
+     char *tz;
+
+     tz = getenv("TZ");
+     setenv("TZ", "", 1);
+     tzset();
+     ret = mktime(tm);
+     if (tz)
+         setenv("TZ", tz, 1);
+     else
+         unsetenv("TZ");
+     tzset();
+     return ret;
+}
+#endif /* Platform switch */
+#endif /* HAVE_TIMEGM */
+
+#define RFC1123_FORMAT "%3s, %02d %3s %4d %02d:%02d:%02d GMT"
+static const char short_months[12][4] = {
+    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
+    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
+};
+/*
+ * This function is borrowed from libneon's ne_httpdate_parse.
+ * Unfortunately that one converts to local time but here UTC is
+ * needed.
+ * This one uses timegm instead, which returns UTC.
+ */
+time_t oc_httpdate_parse( const char *date ) {
+    struct tm gmt;
+    char wkday[4], mon[4];
+    int n;
+    time_t result = 0;
+
+    memset(&gmt, 0, sizeof(struct tm));
+
+    /*  it goes: Sun, 06 Nov 1994 08:49:37 GMT */
+    n = sscanf(date, RFC1123_FORMAT,
+               wkday, &gmt.tm_mday, mon, &gmt.tm_year, &gmt.tm_hour,
+               &gmt.tm_min, &gmt.tm_sec);
+    /* Is it portable to check n==7 here? */
+    gmt.tm_year -= 1900;
+    for (n=0; n<12; n++)
+        if (strcmp(mon, short_months[n]) == 0)
+            break;
+    /* tm_mon comes out as 12 if the month is corrupt, which is desired,
+     * since the mktime will then fail */
+    gmt.tm_mon = n;
+    gmt.tm_isdst = -1;
+    result = timegm(&gmt);
+    return result;
+}
+
+
+/*
+ * helper: convert a resource struct to file_stat struct.
+ */
+csync_vio_file_stat_t *resourceToFileStat( struct resource *res )
+{
+    csync_vio_file_stat_t *lfs = NULL;
+
+    if( ! res ) {
+        return NULL;
+    }
+
+    lfs = c_malloc(sizeof(csync_vio_file_stat_t));
+    if (lfs == NULL) {
+        errno = ENOMEM;
+        return NULL;
+    }
+
+    lfs->name = c_strdup( res->name );
+
+    lfs->fields = CSYNC_VIO_FILE_STAT_FIELDS_NONE;
+    if( res->type == resr_normal ) {
+        lfs->fields |= CSYNC_VIO_FILE_STAT_FIELDS_TYPE;
+        lfs->type = CSYNC_VIO_FILE_TYPE_REGULAR;
+    } else if( res->type == resr_collection ) {
+        lfs->fields |= CSYNC_VIO_FILE_STAT_FIELDS_TYPE;
+        lfs->type = CSYNC_VIO_FILE_TYPE_DIRECTORY;
+    } else {
+        DEBUG_WEBDAV("ERROR: Unknown resource type %d", res->type);
+    }
+
+    lfs->mtime = res->modtime;
+    lfs->fields |= CSYNC_VIO_FILE_STAT_FIELDS_MTIME;
+    lfs->size  = res->size;
+    lfs->fields |= CSYNC_VIO_FILE_STAT_FIELDS_SIZE;
+    if( res->md5 ) {
+        lfs->etag   = c_strdup(res->md5);
+    }
+    lfs->fields |= CSYNC_VIO_FILE_STAT_FIELDS_ETAG;
+    csync_vio_file_stat_set_file_id(lfs, res->file_id);
+
+    return lfs;
+}
+
+/* WebDAV does not deliver permissions. Set a default here. */
+int _stat_perms( int type ) {
+    int ret = 0;
+
+    if( type == CSYNC_VIO_FILE_TYPE_DIRECTORY ) {
+        /* DEBUG_WEBDAV("Setting mode in stat (dir)"); */
+        /* directory permissions */
+        ret = S_IFDIR | S_IRUSR | S_IWUSR | S_IXUSR /* directory, rwx for user */
+                | S_IRGRP | S_IXGRP                       /* rx for group */
+                | S_IROTH | S_IXOTH;                      /* rx for others */
+    } else {
+        /* regualar file permissions */
+        /* DEBUG_WEBDAV("Setting mode in stat (file)"); */
+        ret = S_IFREG | S_IRUSR | S_IWUSR /* regular file, user read & write */
+                | S_IRGRP                         /* group read perm */
+                | S_IROTH;                        /* others read perm */
+    }
+    return ret;
+}
+
+void oc_notify_progress(const char *file, enum csync_notify_type_e kind, int64_t current_size, int64_t full_size)
+{
+  csync_progress_callback progress_cb = csync_get_progress_callback(dav_session.csync_ctx);
+
+  csync_overall_progress_t overall_progress;
+  ZERO_STRUCT(overall_progress);
+
+  if( dav_session.overall_progress_data) {
+    overall_progress = *dav_session.overall_progress_data;
+  }
+
+  if (progress_cb) {
+    CSYNC_PROGRESS progress;
+    progress.kind = kind;
+    progress.path = file;
+    progress.curr_bytes = current_size;
+    progress.file_size  = full_size;
+    progress.overall_transmission_size = overall_progress.byte_sum;
+    progress.current_overall_bytes     = overall_progress.byte_current+current_size;
+    progress.overall_file_count        = overall_progress.file_count;
+    progress.current_file_no           = overall_progress.current_file_no;
+
+    progress_cb(&progress, csync_get_userdata(dav_session.csync_ctx));
+  }
+}
diff --git a/src/csync_private.h b/src/csync_private.h
index b758226..ab6c837 100644
--- a/src/csync_private.h
+++ b/src/csync_private.h
@@ -127,7 +127,6 @@ struct csync_s {
   } remote;
 
   struct {
-    void *handle;
     csync_vio_method_t *method;
     csync_vio_method_finish_fn finish_fn;
     csync_vio_capabilities_t capabilities;
diff --git a/src/vio/csync_vio.c b/src/vio/csync_vio.c
index 148d30c..976598e 100644
--- a/src/vio/csync_vio.c
+++ b/src/vio/csync_vio.c
@@ -56,112 +56,17 @@
 
 int csync_vio_init(CSYNC *ctx, const char *module, const char *args) {
 
-#if defined(_WIN32) || defined(__APPLE__) || defined(WITH_UNIT_TESTING)
-  csync_stat_t sb;
-#endif
-#if defined(_WIN32) || defined(WITH_UNIT_TESTING)
-  mbchar_t *mpath = NULL;
-#endif
-  char *path = NULL;
-  char *err = NULL;
   csync_vio_method_t *m = NULL;
   csync_vio_method_init_fn init_fn;
 
-#ifdef _WIN32
-  mbchar_t tbuf[MAX_PATH];
-  mbchar_t *pathBuf = NULL;
-  char *buf = NULL;
-  char *last_bslash = NULL;
-#endif
-
-#ifdef WITH_UNIT_TESTING
-    if (asprintf(&path, "%s/modules/ocsync_%s.%s", BINARYDIR, module, MODULE_EXTENSION) < 0) {
-        return -1;
-    }
-
-    mpath = c_utf8_to_locale(path);
-    if (_tstat(mpath, &sb) < 0) {
-        SAFE_FREE(path);
-    }
-    c_free_locale_string(mpath);
-#endif
-
-  if (path == NULL) {
-      if (asprintf(&path, "%s/ocsync_%s.%s", PLUGINDIR, module, MODULE_EXTENSION) < 0) {
-          return -1;
-      }
-  }
-
-#ifdef _WIN32
-  mpath = c_utf8_to_locale(path);
-  if (_tstat(mpath, &sb) < 0) {
-      SAFE_FREE(path);
-      /* Change the current working directory to read the module from a relative path. */
-      if( GetModuleFileNameW(NULL, tbuf, MAX_PATH) > 0 ) {
-          buf = c_utf8_from_locale(tbuf);
-          /* cut the trailing filename off */
-          if ((last_bslash = strrchr(buf, '\\')) != NULL) {
-              *last_bslash='\0';
-              pathBuf = c_utf8_to_locale(buf);
-
-              CSYNC_LOG(CSYNC_LOG_PRIORITY_DEBUG, "Win32: changing current working dir to %s", buf);
-              _wchdir(pathBuf);
-              c_free_locale_string(pathBuf);
-          }
-          c_free_locale_string(buf);
-
-          if (asprintf(&path, "modules/ocsync_%s.%s", module, MODULE_EXTENSION) < 0) {
-              return -1;
-          }
-      }
-  }
-  c_free_locale_string(mpath);
-#endif
-
-#ifdef __APPLE__
-  if (lstat(path, &sb) < 0) {
-    char path_tmp[1024];
-    char* path2 = NULL;
-    uint32_t size = sizeof(path_tmp);
-    SAFE_FREE(path);
-
-    if (_NSGetExecutablePath(path_tmp, &size) == 0)
-        printf("executable path is %s\n", path_tmp);
-
-    path2 = c_dirname(path_tmp);
-
-    if (asprintf(&path, "%s/../PlugIns/ocsync_%s.%s", path2, module, MODULE_EXTENSION) < 0) {
-      return -1;
-    }
-  }
-#endif
-
-  ctx->module.handle = dlopen(path, RTLD_LAZY);
-  SAFE_FREE(path);
-  if ((err = dlerror()) != NULL) {
-    (void) err;
-    /* Disable this log message as that tremendously confuses users. See log in csync.c */
-    /* CSYNC_LOG(CSYNC_LOG_PRIORITY_ERROR, "loading %s plugin failed - %s",
-     *        module, err); */
-    return -1;
-  }
-
-  *(void **) (&init_fn) = dlsym(ctx->module.handle, "vio_module_init");
-  if ((err = dlerror()) != NULL) {
-    CSYNC_LOG(CSYNC_LOG_PRIORITY_ERROR, "loading function failed - %s", err);
-    return -1;
-  }
-
-  *(void **)  (&ctx->module.finish_fn) = dlsym(ctx->module.handle,
-                                               "vio_module_shutdown");
-  if ((err = dlerror()) != NULL) {
-    CSYNC_LOG(CSYNC_LOG_PRIORITY_ERROR, "loading function failed - %s", err);
-    return -1;
-  }
+  /* The owncloud module used to be dynamically loaded, but now it's just statically linked */
+  extern csync_vio_method_t *vio_module_init(const char *method_name, const char *config_args, csync_auth_callback cb, void *userdata);
+  extern void vio_module_shutdown(csync_vio_method_t *);
+  init_fn = vio_module_init;
+  ctx->module.finish_fn = vio_module_shutdown;
 
   /* get the method struct */
-  m = (*init_fn)(module, args, csync_get_auth_callback(ctx),
-      csync_get_userdata(ctx));
+  m = init_fn(module, args, csync_get_auth_callback(ctx), csync_get_userdata(ctx));
   if (m == NULL) {
     CSYNC_LOG(CSYNC_LOG_PRIORITY_ERROR, "module %s returned a NULL method", module);
     return -1;
@@ -227,19 +132,13 @@ int csync_vio_init(CSYNC *ctx, const char *module, const char *args) {
 }
 
 void csync_vio_shutdown(CSYNC *ctx) {
-  if (ctx->module.handle != NULL) {
     /* shutdown the plugin */
     if (ctx->module.finish_fn != NULL) {
       (*ctx->module.finish_fn)(ctx->module.method);
     }
 
-    /* close the plugin */
-    dlclose(ctx->module.handle);
-    ctx->module.handle = NULL;
-
     ctx->module.method = NULL;
     ctx->module.finish_fn = NULL;
-  }
 }
 
 csync_vio_handle_t *csync_vio_open(CSYNC *ctx, const char *uri, int flags, mode_t mode) {
diff --git a/tests/vio_tests/check_vio.c b/tests/vio_tests/check_vio.c
index 0fb28bb..21df68f 100644
--- a/tests/vio_tests/check_vio.c
+++ b/tests/vio_tests/check_vio.c
@@ -79,38 +79,6 @@ static void teardown(void **state) {
     *state = NULL;
 }
 
-static void check_csync_vio_load(void **state)
-{
-    CSYNC *csync = *state;
-    int rc;
-
-    rc = csync_vio_init(csync, "owncloud", NULL);
-    assert_int_equal(rc, 0);
-
-    csync_vio_shutdown(csync);
-}
-
-static void check_csync_vio_load_wrong_proto(void **state)
-{
-    CSYNC *csync = *state;
-    int rc;
-
-    rc = csync_vio_init(csync, "wrong", NULL);
-    assert_int_equal(rc, -1);
-
-    csync_vio_shutdown(csync);
-}
-
-static void check_csync_vio_load_bad_plugin(void **state)
-{
-    CSYNC *csync = *state;
-    int rc;
-
-    rc = csync_vio_init(csync, "bad", NULL);
-    assert_int_equal(rc, -1);
-
-    csync_vio_shutdown(csync);
-}
 
 /*
  * Test directory function
@@ -549,9 +517,6 @@ static void check_csync_vio_utimes(void **state)
 int torture_run_tests(void)
 {
     const UnitTest tests[] = {
-        unit_test_setup_teardown(check_csync_vio_load, setup, teardown),
-        unit_test_setup_teardown(check_csync_vio_load_wrong_proto, setup, teardown),
-        unit_test_setup_teardown(check_csync_vio_load_bad_plugin, setup, teardown),
 
         unit_test_setup_teardown(check_csync_vio_mkdir, setup, teardown),
         unit_test_setup_teardown(check_csync_vio_mkdirs, setup, teardown),
